<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[以最优雅的方式做算法竞赛]]></title>
    <url>%2F2019%2F07%2F12%2FVScode-C-Algorithmic-Competition%2F</url>
    <content type="text"><![CDATA[自从在大学入坑了ICPC这类算法比赛，就沉迷其中，在集训队的时候花上一整天做各种各样的比赛，写各种各样的题目，日常的话，也会在深夜打开codeforces，参加一场场的掉分赛/(ㄒoㄒ)/~~ 刚开始写比赛的时候，用的IDE是Dev C++，这款IDE上手简单，对新手比较友好，但是调试能力较弱；之后改用CodeBlocks，相对而言功能更加丰富，可自定义的地方也比较多，但麻烦之处在于需要建工程，以及对我来说，调试相当不友好，UI也比较丑；也见过有人使用Visual Studio，不过庞大的体量让我瞬间失去了用它做题的想法。 除了IDE本身的缺陷，还有一个比较难以忍受的共性问题是，竞赛的输入输出是分开的，区分十分清晰，但选手在编写程序的时候，需要在终端里同时完成输入输出，难免会产生混乱，如果在代码中使用了重定向，又需要分心去管理重定向的事情，就有点舍本逐末了。 综上，理想中算法竞赛刷题工具应有以下几个便利点： 允许单文件编译运行，使得做一道题目不需要大费周章的建立工程，只需要一个单文件。 界面美观，友好，调试方便。 直接重定向到文件。 一番摸索之后，我选择的工具是vscode，主要是基于一下几点考虑： 界面美观。 编辑器可自由拖拽，观看方便。 拥有大量插件，功能高度自定义。 于是，踏上了配置之旅。 想看简易配置过程直接拉到最后。 效果展示 主要功能： 源代码放在 src 文件夹中，编译生成的可执行程序在 bin 文件夹中，用于重定向的输入输出文件放在 data 中，vscode的配置文件放在 .vscode 中。 在一个源文件中编写完程序之后按下F5一键编译运行，程序重定向输入自data.in，重定向输出至data.out中。 可自由选择需要编译的源文件，各个文件之间不冲突。 配置思路本配置是从官方的配置魔改而来，先贴一下官方的 task.json 及 launch.json 两个配置文件： 123456789101112131415161718192021// task.json&#123; "version": "2.0.0", "tasks": [ &#123; "label": "build hello world", "type": "shell", "command": "g++", "args": [ "-g", "-o", "helloworld", "helloworld.cpp" ], "group": &#123; "kind": "build", "isDefault": true &#125; &#125; ]&#125; 1234567891011121314151617181920212223242526//launch.json&#123; "version": "0.2.0", "configurations": [ &#123; "name": "(gdb) Launch", "type": "cppdbg", "request": "launch", "program": "$&#123;workspaceFolder&#125;/helloworld.exe", "args": [], "stopAtEntry": true, "cwd": "$&#123;workspaceFolder&#125;", "environment": [], "externalConsole": false, "MIMode": "gdb", "miDebuggerPath": "C:/mingw-w64/x86_64-8.1.0-win32-seh-rt_v6-rev0/mingw64/bin/gdb.exe", "setupCommands": [ &#123; "description": "Enable pretty-printing for gdb", "text": "-enable-pretty-printing", "ignoreFailures": true &#125; ] &#125; ]&#125; 不难看出，task.json中的build hello world任务是调用了g++命令，而它的参数是 -g -o helloworld helloworld.cpp，即编译helloworld.cpp；launch.json则是在编译完后调试 ${workspaceFolder} 目录下的helloworld.exe。 而我们希望的功能是编译任意一个单源文件，并重定向输入输出。在task中需要指定编译文件的路径，vscode提供了几个预定义的宏变量用来表示路径。 那么，可以通过 ${file} 来表示正在编辑的文件路径，使用 ${workspaceFolder} 加上相对路径以及 ${fileBasenameNoExtension} 来指定生成可执行文件的路径与名称。那么，假如源文件都在src文件夹中，希望生成的可执行文件都在bin中，则task.json中的args参数修改为 1234"args": [ "-g", "$&#123;file&#125;", "-o", "$&#123;workspaceFolder&#125;/bin/$&#123;fileBasenameNoExtension&#125;.exe"] 而重定向则可以由 &gt; 与 &lt; 来进行，假如希望重定向的文件都在data文件夹中，输入文件为data.in，输出文件为data.out，则launch.json中的program与args参数修改为 1234567"program": "$&#123;workspaceFolder&#125;/bin/$&#123;fileBasenameNoExtension&#125;.exe","args": [ "&lt;", "$&#123;workspaceFolder&#125;/data/data.in", "&gt;", "$&#123;workspaceFolder&#125;/data/data.out"] 大功告成。 简易配置过程 按照官方教程或者我之前的文章配置好一个C/C++编程环境。 在工作目录下新建bin，data，src三个文件夹，将源文件放入src文件夹中，可执行文件放入bin中。 在data文件夹中新建两个文本文件，分别为data.in与data.out。此时工作区的文件结构为： 123456789101112|--.vscode| --c_cpp_properties.json| --launch.json| --settings.json| --tasks.json|--bin| --helloworld.exe|--data| --data.in| --data.out|-src| --helloworld.cpp 修改task.json中的参数args 1234"args": [ "-g", "$&#123;file&#125;", "-o", "$&#123;workspaceFolder&#125;/bin/$&#123;fileBasenameNoExtension&#125;.exe"] 此时task.json应该类似于： 1234567891011121314151617181920&#123; "version": "2.0.0", "tasks": [ &#123; "label": "build hello world", "type": "shell", "command": "g++", "args": [ "-g", "$&#123;file&#125;", "-o", "$&#123;workspaceFolder&#125;/bin/$&#123;fileBasenameNoExtension&#125;.exe" ], "group": &#123; "kind": "build", "isDefault": true &#125; &#125; ]&#125; 修改launch.json中的参数program与args为 1234567"program": "$&#123;workspaceFolder&#125;/bin/$&#123;fileBasenameNoExtension&#125;.exe","args": [ "&lt;", "$&#123;workspaceFolder&#125;/data/data.in", "&gt;", "$&#123;workspaceFolder&#125;/data/data.out"] 此时launch.json应该类似于： 12345678910111213141516171819202122232425262728&#123;"version": "0.2.0","configurations": [&#123; "name": "(gdb) Launch", "type": "cppdbg", "request": "launch", "program": "$&#123;workspaceFolder&#125;/bin/$&#123;fileBasenameNoExtension&#125;.exe", "args": [ "&lt;", "$&#123;workspaceFolder&#125;/data/data.in", "&gt;", "$&#123;workspaceFolder&#125;/data/data.out" ], "stopAtEntry": true, "cwd": "$&#123;workspaceFolder&#125;", "environment": [], "externalConsole": false, "MIMode": "gdb", "miDebuggerPath": "C:/mingw-w64/x86_64-8.1.0-win32-seh-rt_v6-rev0/mingw64/bin/gdb.exe", "setupCommands": [ &#123; "description": "Enable pretty-printing for gdb", "text": "-enable-pretty-printing", "ignoreFailures": true &#125; ] &#125;]&#125; 配置完成,拖拽编辑器到合适的位置 编辑完代码后，按下F5一键编译运行，程序将重定向输入自data/data.in，重定向输出至data.out 保存一份配置好的文件夹作为模板，后续需要做比赛的时候复制一份。 后续本次配置难度不是很大，灵活使用vscode的宏变量进行配置，也比较好理解。最终的结果满足了我打比赛的需求，不过还是存在一下几点问题： 每次使用都需要重新设置一下布局，虽然不是很麻烦但是很繁琐。 无法识别编辑文件的文件类型，如果在修改了data.in后直接编译，会报错。 好了，开开心心掉分去QAQ。]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用VScode编写C++工程]]></title>
    <url>%2F2019%2F03%2F08%2Fc-withVScode-second%2F</url>
    <content type="text"><![CDATA[VS code 是个功能强大，可扩展性极强的编辑器，通过添加一些插件，修改一下配置即可发挥强大的功能。 前些日子（其实好久了哈 (￣ y▽ ￣)~*），通过阅读官网的文档，成功配置了 C++的编程环境，然后用了很久。但是最近遇见了个很严重的问题，那就是按照官网的文档走的话，最终只能编译，调试，运行一个单独的文件。 这就很难受了，虽说刷刷算法题也不需要多个文件，使用 g++的一些较为复杂的参数也可以编译链接多个文件，但是，到底能不能使用 VS code 来编写具有一定规模的 C/C++工程呢？ 于是，折腾开始了，而且最终取得了很不错的成果。(≖‿≖)✧ 折腾之前因为之前的配置，所以计算机上至少有的环境是：安装好了 MingW，设置过了全局，安装了官网文档中所需要的插件以及写好了配置。 要是这一步没有做过的话可以参考我之前的文章使用 VScode 编写 C++文件，或者阅读官方文档。 准备好了，开始！ o(*≧▽≦)ツ 安装 C/C++ Project Generator在最早配置 C++编程环境的时候，就有过这个插件的印象，只是没实际使用过，不过，看名字貌似是我们想要的插件，emmmm，那就安装！ 按照文档的提示： How to use Go to command pallete (usually : ctrl + shift + p) Search for “Create C project” or “Create c++ project” depending on your preference Select the folder where the project should be created That’s it, project will open 使用ctrl + shift + p 调出命令界面。 根据需要输入 Create C project 或者 Create c++ project 查找相关命令选择建立 C 工程或者 C++工程（本次折腾用的是 C++工程） 选择希望在哪里建立工程 到这里就结束了，工程建立完毕 嗯，那根据它的说法来一次。 可以看到已经有了一个工程的雏形，插件也很贴心的给了示例程序。 那好，然后按下F5开始调试。 ∑(っ °Д°;)っ开始运行了！竟然如此简单！ 完结撒花( ^３^ )╱~~❀❀❀ 才怪(/= _ =)/~┴┴ 修改 launch.json 文件那好，咱们去launch.json看看。 1234567891011121314151617181920212223242526&#123; "version": "0.2.0", "configurations": [ &#123; "name": "Debug", "type": "cppdbg", "request": "launch", "program": "$&#123;workspaceFolder&#125;/bin/main.exe", "args": [], "stopAtEntry": false, "cwd": "$&#123;workspaceRoot&#125;", "environment": [], "externalConsole": true, "preLaunchTask": "build", "linux": &#123; "MIMode": "gdb" &#125;, "osx": &#123; "MIMode": "lldb" &#125;, "windows": &#123; "MIMode": "gdb" &#125; &#125; ]&#125; emmmm 还是能简单看懂一些的了，大致是在官方的模板下少许修改了一下，甚至贴心的为不同的环境选择了不同的调试器，那么，问题出在哪里呢？ 贴一下之前按照官方给的配置文件模板。 1234567891011121314151617181920212223242526&#123; "version": "0.2.0", "configurations": [ &#123; "name": "(gdb) Launch", "type": "cppdbg", "request": "launch", "program": "$&#123;workspaceFolder&#125;/a.exe", "args": [], "stopAtEntry": false, "cwd": "$&#123;workspaceFolder&#125;", "environment": [], "externalConsole": true, "MIMode": "gdb", "miDebuggerPath": "C:\\mingw\\bin\\gdb.exe", "setupCommands": [ &#123; "description": "Enable pretty-printing for gdb", "text": "-enable-pretty-printing", "ignoreFailures": true &#125; ], "preLaunchTask": "build hello world" &#125; ]&#125; 稍加思索 显然，该配置文件没有配置调试器的路径，于是加上配置&quot;miDebuggerPath&quot;，一通魔改融合后，修改完的launch.json长这个样子： 1234567891011121314151617181920212223242526&#123; "version": "0.2.0", "configurations": [ &#123; "name": "(gdb) Launch", "type": "cppdbg", "request": "launch", "program": "$&#123;workspaceFolder&#125;/bin/main.exe", "args": [], "stopAtEntry": false, "cwd": "$&#123;workspaceFolder&#125;", "environment": [], "externalConsole": true, "MIMode": "gdb", "miDebuggerPath": "C:\\MinGW\\mingw64\\bin\\gdb.exe", "setupCommands": [ &#123; "description": "Enable pretty-printing for gdb", "text": "-enable-pretty-printing", "ignoreFailures": true &#125; ], "preLaunchTask": "build" &#125; ]&#125; =￣ ω ￣= 因为我还只是在 Windows 上配置环境，没考虑跨平台，于是就只保留了 Windows 上的配置。 miDebuggerPath和preLaunchTask的值因人而异吧，我是改了一堆，但实际上只需要加上miDebuggerPath就行了。 那，再试试？ 喜极而泣(´°̥̥̥̥̥̥̥̥ω°̥̥̥̥̥̥̥̥ ｀) 开开心心设断点，开开心心 debug(｀･ω･´) 喵~？ 我的断点呢？ 它怎么灰了 ಠ౪ಠ？ 它怎么没停下来 ಥ_ಥ？ 怎么变量没自己打开 (╯‵□′)╯︵┻━┻？ 我去，还是无效值(╬▔ 皿 ▔)！ (/“≡ _ ≡)/~┴┴ g++ -g鬼知道我查了多久资料( ＿ ＿)ノ｜ 来大致谈谈这个插件的一些细节。 作者的思路蛮正确的，基本上还是官方给的配置，然后魔改了一下，比如说task里需要放很多的任务，其中有一个叫做“build”，在官网的模板中，这个任务是要调用命令行里的g++命令来编译程序，但是指定了编译时的源文件与生成文件，这就导致写代码的时候文件名不能出错。 但实际上在一个工程中，需要编译的文件可能是多个，所依赖的头文件也会是多个，这些在生成可执行程序的时候都是需要考虑到的，诚然，可以通过 g++丰富的参数写下长长的命令来实现编译链接多个源文件，可是毕竟麻烦，而且还容易出错。 于是作者使用了 Makefile 这个工具。Makefile 是一个比较有意思的工具，简单的说，它可以通过检查一些依赖项，然后调用一些命令加上相应的参数生成所需要的文件。 用在编译程序上可谓是刚刚好。 所以在作者的修改下，task 文件中的任务被描述为调用 Makefile 的一些命令，而 Makefile 里又进行了相应的配置，将依赖项分别放入src，_lib_，include中，调用g++命令编译文件。 Makefile 里最重要的几句无疑就是最后这个了： 12$(BIN)/$(EXECUTABLE): $(SRC)/* $(CC) $(C_FLAGS) -I$(INCLUDE) -L$(LIB) $^ -o $@ $(LIBRARIES) 这句中的 CC 是命令g++，后面相关的参数有-I，-L，-o等，这些参数的详细说明我就不介绍了，贴出来我查找到的一些资料： g++命令参数的作用即用法 那么问题出现在哪里呢？ 再列出我参考的一些资料： C/C++ Project Generator 的反馈中，国外某位程序员的回答 StackOverFlow 上，关于 VS code 无法调试的回答 以及官网给出的task模板： 123456789101112131415&#123; "version": "2.0.0", "tasks": [ &#123; "label": "build hello world", "type": "shell", "command": "g++", "args": ["-g", "helloworld.cpp"], "group": &#123; "kind": "build", "isDefault": true &#125; &#125; ]&#125; 虽然一下子列出来资料会得出显而易见的结论，但鬼知道为了找到这些资料有多辛苦（╯－＿－）╯╧╧ 总的来说，就是原作者在写Makefile的时候，漏掉了一个参数-g，导致无法调试，那么所需要进行的修改就是给它加上。 修改后的 Makefile 最后几句如下： 12$(BIN)/$(EXECUTABLE): $(SRC)/* $(CC) $(C_FLAGS) -I$(INCLUDE) -L$(LIB) -g $^ -o $@ $(LIBRARIES) 调试，启动(*ﾟ ▽ ﾟ*) 开开心心 Debug。（＾ ∀ ＾） 完整的配置贴出魔改之后我的配置文件吧： launch.json 1234567891011121314151617181920212223242526&#123; "version": "0.2.0", "configurations": [ &#123; "name": "(gdb) Launch", "type": "cppdbg", "request": "launch", "program": "$&#123;workspaceFolder&#125;/bin/main.exe", "args": ["&lt;", "bin\\data.in", "&gt;", "bin\\data.out"], "stopAtEntry": false, "cwd": "$&#123;workspaceFolder&#125;", "environment": [], "externalConsole": false, "MIMode": "gdb", "miDebuggerPath": "C:\\MinGW\\mingw64\\bin\\gdb.exe", "setupCommands": [ &#123; "description": "Enable pretty-printing for gdb", "text": "-enable-pretty-printing", "ignoreFailures": true &#125; ], "preLaunchTask": "build main" &#125; ]&#125; task.json 123456789101112131415&#123; "version": "2.0.0", "tasks": [ &#123; "label": "build main", "type": "shell", "command": "powershell", "args": ["-c", "mingw32-make"], "group": &#123; "kind": "build", "isDefault": true &#125; &#125; ]&#125; Makefile 1234567891011121314151617181920212223242526CC := g++C_FLAGS := -std=c++17 -Wall -WextraBIN := binSRC := srcINCLUDE := includeLIB := libLIBRARIES :=ifeq ($(OS),Windows_NT)EXECUTABLE := main.exeelseEXECUTABLE := mainendifall: $(BIN)/$(EXECUTABLE)clean: $(RM) $(BIN)/$(EXECUTABLE)run: all ./$(BIN)/$(EXECUTABLE)$(BIN)/$(EXECUTABLE): $(SRC)/* $(CC) $(C_FLAGS) -I$(INCLUDE) -L$(LIB) -g $^ -o $@ $(LIBRARIES) 写在最后折腾了一天后，有了个较为完善的解决方案，很可惜的是，没有找到可以完美创建，调试 C++工程的插件，但是可以根据已有的思路一步步完善自己的配置。 我的想法是，将已经配置好的 vscode 工程文件存为模板文件，需要的时候拷贝一份使用，于是，原插件也用不上了。 其实原来的插件稍加修改一下也可以完美胜任的，但是原作者貌似已经好久不更新了，无论是在 VS code 的插件库，还是原作者的 GitHub 库，都已经有人进行了一系列反映，甚至给出了解决方案，但是貌似作者并没有看到哈。博主又比较笨，不会修改原作者的代码，那就先这样用吧。 有一点比较在意的是，在很多 IDE 中，如果创建的是终端工程的话，会在程序运行结束后停留在结束界面。这点除了在代码最后调用系统命令pause外，没有什么好的办法。 但毕竟 C++不是只用来写终端程序的，这一点倒也不是很严重。 那就这样吧。(/・ω・＼)]]></content>
      <categories>
        <category>教程</category>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十大排序]]></title>
    <url>%2F2019%2F02%2F22%2FTopTenSort%2F</url>
    <content type="text"><![CDATA[从大一学 C 语言开始就一直听说有个叫做十大排序算法的东西，要涉及一些有趣的思想和数据结构什么的，听起来很厉害的样子，觉得好难就没去看过，只是调用 qsort 和 sort 之类的函数。 最近学一些东西的时候恰巧和十大排序打了交道，理解起来并不难，拖延了好久才去看真的挺遗憾的。然后学完后打算把十大排序总结记录下来。 所谓十大排序是十种比较经典，综合了很多经典思路的排序算法。分别是冒泡排序，选择排序，插入排序，希尔排序，归并排序，快速排序，堆排序，计数排序，桶排序，基数排序。 本篇文章的动画演示录制自VisualGo,panthema与USF 部分算法的介绍来自维基百科 以 C/C++混合风格实现 冒泡排序冒泡排序(Bubble Sort)是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 实现的基本思路就是两个循环嵌套起来，比较相邻元素，将大的元素逐渐后移，小的元素就逐渐浮到了前面。 12345678910111213void BubbleSort(int array[], int len)&#123; for (int i = 0; i &lt; len; i++) &#123; for (int j = 0; j &lt; len - i - 1; j++) &#123; if (array[j] &gt; array[j + 1]) &#123; swap(array[j], array[j + 1]); &#125; &#125; &#125;&#125; 选择排序选择排序(Selection sort)是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 当然，也可以同时选出最大元素和最小元素，将它们分别放入两边。 123456789101112131415void SelectionSort(int array[], int len)&#123; for (int i = 0; i &lt; len; i++) &#123; int minIndex = i; for (int j = i + 1; j &lt; len; j++) &#123; if (array[j] &lt; array[minIndex]) &#123; minIndex = j; &#125; &#125; swap(array[i], array[minIndex]); &#125;&#125; 插入排序插入排序(Insertion Sort)是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 12345678910111213void InsertionSort(int array[], int len)&#123; for (int i = 1; i &lt; len; i++) &#123; int temp = array[i]; int j = i - 1; for (; (j &gt;= 0) &amp;&amp; (array[j] &gt; temp); j--) &#123; array[j + 1] = array[j]; &#125; array[j + 1] = temp; &#125;&#125; 希尔排序希尔排序(Shell Sort)实际上是插入排序的一种变形。插入排序在比较的时候总是和前一个进行比较然后交换，而插入排序是从一个比较大的间隔起，逐渐缩短到一。 经典的希尔排序在取间隔的时候设置为 n/2，n/4，n/8，在不断缩小间隔进行插入排序。 引用来自维基百科的说法： 假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为 5 开始进行排序，我们可以通过将这列表放在有 5 列的表中来更好地描述算法，这样他们就应该看起来是这样： 13 14 94 33 8225 59 94 65 2345 27 73 25 3910 然后我们对每列进行排序： 10 14 73 25 2313 27 94 33 3925 59 94 65 8245 将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时 10 已经移至正确位置了，然后再以 3 为步长进行排序： 10 14 7325 23 1327 94 3339 25 5994 65 8245 排序之后变为： 10 14 1325 23 3327 25 5939 65 7345 94 8294 最后以 1 步长进行排序（此时就是简单的插入排序了）。 值得一提的是虽然希尔排序的作者 Donald Shell 最初建议的间隔是(1, 2, 4, … n/2)，但是间隔的选取只要是从大到小，最后到达 1 即可。目前为止已知的效率最优秀的间隔是 Sedgewick 提出的(1, 5, 19, 41, 109,…)。 12345678910111213141516void ShellSort(int array[], int len)&#123; for (int gap = len &gt;&gt; 1; gap &gt; 0; gap &gt;&gt;= 1) &#123; for (int i = gap; i &lt; len; i++) &#123; int temp = array[i]; int j = i - gap; for (; (j &gt;= 0) &amp;&amp; (array[j] &gt; temp); j -= gap) &#123; array[j + gap] = array[j]; &#125; array[j + gap] = temp; &#125; &#125;&#125; 归并排序归并排序(Merge Sort)是一种采取分治法进行排序的算法。在我看来可以这样理解归并排序： 将两个有序数组合成一条有序数组； 若数组中只有一个元素则自然有序。 归并排序有多种实现方式，比较经常见到的有递归法和迭代法。相比而言，递归法比较容易理解。 对于一个长度为 n 的序列，递归方式的归并排序可以描述成： 排序序列前 n/2 与后 n/2； 合并前后两个有序序列； 排序完成 123456789101112131415161718192021222324252627282930313233343536373839void MergeRecursive(int array[], int help[], int start, int end)&#123; if (start &gt;= end) return; int len = end - start, mid = (len &gt;&gt; 1) + start; int start1 = start, end1 = mid; int start2 = mid + 1, end2 = end; MergeRecursive(array, help, start1, end1); //对数组前一半进行排序 MergeRecursive(array, help, start2, end2); //对数组后一半进行排序 //合并两个有序数组 int index = start; int start11 = start1, end11 = end1, start22 = start2, end22 = end2; while ((start1 &lt;= end1) &amp;&amp; (start2 &lt;= end2)) &#123; help[index++] = array[start1] &lt; array[start2] ? array[start1++] : array[start2++]; &#125; while (start1 &lt;= end1) &#123; help[index++] = array[start1++]; &#125; while (start2 &lt;= end2) &#123; help[index++] = array[start2++]; &#125; //将合并后的结果复制回原数组。 for (int i = start; i &lt;= end; i++) &#123; array[i] = help[i]; &#125;&#125;void MergeSort(int array[], int len)&#123; int *help = new int[len]; MergeRecursive(array, help, 0, len - 1); delete[] help;&#125; 递归法可以看作是归并排序的自顶向下的实现方式，而迭代法更多的体现的是自底向上的实现方法。 对于一个长度为 n 的序列，迭代方式的归并排序可以描述成： len = 1； 合并两两相邻的长度长度为 len 的序列； len *= 2； 如果 len &lt; n,回到 2； 排序完成。 12345678910111213141516171819202122232425262728293031323334353637void MergeSort(int array[], int len)&#123; int *arr = array; int *help = new int[len]; for (int dis = 1; dis &lt; len; dis *= 2) &#123; for (int start = 0; start &lt; len; start += 2 * dis) &#123; int low = start, mid = min(start + dis, len), high = min(start + 2 * dis, len); int start1 = start, end1 = mid; int start2 = mid, end2 = high; int index = start; while ((start1 &lt; end1) &amp;&amp; (start2 &lt; end2)) &#123; help[index++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++]; &#125; while (start1 &lt; end1) &#123; help[index++] = arr[start1++]; &#125; while (start2 &lt; end2) &#123; help[index++] = arr[start2++]; &#125; &#125; swap(arr, help); &#125; if (arr != array) &#123; for (int i = 0; i &lt; len; i++) &#123; array[i] = arr[i]; &#125; help = arr; &#125; delete[] help;&#125; 我认为在迭代法中最巧妙的一步是swap(arr, help)，交换了原数组与辅助数组的指针，这样做让两个数组轮流做为辅助数组，省去了将辅助数组复制回原数组的开销，只在最后排完序后判断一下是否是原序列即可。相当巧妙！ 快速排序快速排序(Quicksort)也是一种分治的排序算法。与归并相比，快速排序更注重与划分子问题，而归并排序更注重于合并子问题，因此在具体的思路上会有较大的不同。 对于一个数组来讲，快速排序可以被描述成： 如果数组长度小于等于 1，则排序完成； 选取数组中的一个元素，将所有小于该元素的元素放在数组前部分，所有大于该元素的元素放在数组后部分，该元素放在正中间； 对数组前一部分和后一部分进行排序； 排序完成。 1234567891011121314151617181920void QuickSort(int array[], int len)&#123; if (len &lt;= 1) return; int low = 1, high = len - 1; while (low &lt;= high) &#123; if (array[low] &lt; array[0]) &#123; low++; &#125; else &#123; swap(array[low], array[high--]); &#125; &#125; swap(array[0], array[high]); QuickSort(array, low - 1); QuickSort(array + low, len - low);&#125; 2019年7月15日更新，使用标准库实现了更优雅的写法 123456789void quicksort(ForwardIt first, ForwardIt last)&#123; if(first == last) return; auto pivot = *std::next(first, std::distance(first,last)/2); ForwardIt middle1 = std::partition(first, last, [pivot](const auto&amp; em)&#123; return em &lt; pivot; &#125;); ForwardIt middle2 = std::partition(middle1, last, [pivot](const auto&amp; em)&#123; return !(pivot &lt; em); &#125;); quicksort(first, middle1); quicksort(middle2, last);&#125; 堆排序堆排序(Heap Sort)是一种借助数据结构堆的性质进行排序的算法。 由于堆本身可以使用数组进行实现，因此可以将数组堆化成一个大顶堆或者小顶堆，不断 pop 出堆顶元素并存起来，就是排序结果(大顶堆对应升序，小顶堆对应降序)。 堆化： 不断 pop： 在实际实现过程中，数组的首元素下标为 0，所以需要对堆的实现稍微做些调整。 12345678910111213141516171819202122232425262728293031323334353637383940414243void BuildMaxHeap(int array[], int father, int len)&#123; if (father &gt;= len) return; int leftSon = (father &lt;&lt; 1) + 1, rightSon = (father &lt;&lt; 1) + 2; if (rightSon &lt; len) &#123; if (array[father] &lt; max(array[leftSon], array[rightSon])) &#123; if (array[rightSon] &gt; array[leftSon]) &#123; swap(array[father], array[rightSon]); BuildMaxHeap(array, rightSon, len); &#125; else &#123; swap(array[father], array[leftSon]); BuildMaxHeap(array, leftSon, len); &#125; &#125; &#125; else if (leftSon &lt; len) &#123; if (array[leftSon] &gt; array[father]) &#123; swap(array[father], array[leftSon]); BuildMaxHeap(array, leftSon, len); &#125; &#125;&#125;void HeapSort(int array[], int len)&#123; for (int i = len - 1; i &gt;= 0; i--) &#123; BuildMaxHeap(array, i, len); &#125; for (int i = len - 1; i &gt;= 0; i--) &#123; swap(array[0], array[i]); BuildMaxHeap(array, 0, i); &#125;&#125; 计数排序计数排序(Counting Sort)是一种比较暴力，但是在一定场合下，效率又非常高的排序算法。 就如名字中的计数一样，计数排序的本质是使用额外的辅助空间记录下一个数字出现的次数，然后按照顺序返还会原数组。计数排序特别适应于数据相对集中，重复率特别大的情况，此时计数排序的效率可以达到很高。 在实际情况下，可以用多种方式处理负数数据，本次实现采用的是偏移的方式，将原数组的跨度映射到自 0 始的一段相同跨度的数组(有个特别神奇的操作是利用 C\C++可以使用指针的特点使用负数下标)。 12345678910111213141516171819202122232425void CountingSort(int array[], int len)&#123; int maxValue = array[0], minValue = array[0]; for (int i = 1; i &lt; len; i++) &#123; maxValue = max(array[i], maxValue); minValue = min(array[i], minValue); &#125; int length = maxValue - minValue + 1; int *help = new int[length]; memset(help, 0, (length) * sizeof(int)); for (int i = 0; i &lt; len; i++) &#123; help[array[i] - minValue]++; &#125; ShowArray(help, length); for (int i = 0, j = 0; i &lt;= maxValue - minValue; i++) &#123; while (help[i]--) &#123; array[j++] = i + minValue; &#125; &#125; delete[] help;&#125; 桶排序桶排序(Bucket Sort)就有些一言难尽。 桶排序的具体思路是将原数组的元素在某个大小区域内的所有元素放在一个“桶”中，最后将所有的桶内元素再复制回原数组。 因为桶内元素的具体数量并不能提前确定，因此需要使用可以灵活调整大小的数据结构来实现桶，实际实现的时候，采取了链表来实现桶。 桶排序的一个关键是要保证将桶内元素复制回原数组时需要保证桶内的元素一定是有序的，而实现这一点的方式有很多种，既可以在装桶的时候采取插入排序，也可以在装桶结束后使用链表版本的归并排序或者其他排序手段。 本次实现采取的是装桶过程中使用插入排序，并配合排序原理封装了一个简单的链表。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Node&#123; public: Node(); Node(int data, Node *next = nullptr); int data; Node *next;&#125;;Node::Node()&#123; this-&gt;next = nullptr;&#125;Node::Node(int data, Node *next)&#123; this-&gt;data = data; this-&gt;next = nullptr;&#125;void InsertNode(Node *head, Node *node)&#123; Node *iterator = head; for (; iterator-&gt;next != nullptr; iterator = iterator-&gt;next) &#123; if (iterator-&gt;next-&gt;data &gt; node-&gt;data) &#123; break; &#125; &#125; node-&gt;next = iterator-&gt;next; iterator-&gt;next = node;&#125;void BucketSort(int array[], int len)&#123; int maxValue = array[0], minValue = array[0]; for (int i = 0; i &lt; len; i++) &#123; maxValue = max(maxValue, array[i]); minValue = min(minValue, array[i]); &#125; const int bucketCount = 10; Node *buckets = new Node[bucketCount]; int distance = (maxValue - minValue) / (bucketCount) + 1; for (int i = 0; i &lt; len; i++) &#123; int index = (array[i] - minValue) / distance; InsertNode(buckets + index, new Node(array[i])); &#125; for (int i = 0, j = 0; i &lt; bucketCount; i++) &#123; for (Node *iterator = buckets[i].next; iterator != nullptr; iterator = buckets[i].next) &#123; array[j++] = iterator-&gt;data; buckets[i].next = iterator-&gt;next; delete iterator; &#125; &#125; delete[] buckets;&#125; 基数排序基数排序(Radix Sort)就有些意思了，它在原理上和计数排序有点类似，但是区别在于计数排序需要能容纳该数组所有元素的很多桶，而基数排序只需要十个桶，然后把元素按照每一位进行装桶，复制回原数组，再在高位装桶直到超过最大元素的位数。 基数排序有点像是使用桶排序对每一位进行排序后的结果。 有一点需要注意的是，向桶内放数和从桶内取数的顺序是刚好相反的，不然会破环由低位排序而形成的相对大小关系。 因此，需要一种可以灵活调整大小的线性结构，可以通过一端放数而从另一端取数。 或许双向链表比较符合期望，但实际上使用队列会更加合适而且容易实现，因此本次实现按照排序原理封装了一个简单的队列(亦可使用 STL 中的队列)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class node&#123; public: node(int data, node *prev = nullptr, node *next = nullptr); int data; node *prev, *next;&#125;;class queue&#123; public: queue(); void push(int data); int pop(); bool empty(); private: node *head;&#125;;node::node(int data, node *prev, node *next)&#123; this-&gt;data = data; this-&gt;prev = prev; this-&gt;next = next;&#125;queue::queue()&#123; this-&gt;head = new node(-1); this-&gt;head-&gt;prev = this-&gt;head-&gt;next = this-&gt;head;&#125;void queue::push(int data)&#123; node *temp = new node(data, this-&gt;head, this-&gt;head-&gt;next); this-&gt;head-&gt;next-&gt;prev = temp; this-&gt;head-&gt;next = temp;&#125;int queue::pop()&#123; node *temp = this-&gt;head-&gt;prev; temp-&gt;prev-&gt;next = temp-&gt;next; temp-&gt;next-&gt;prev = temp-&gt;prev; int data = temp-&gt;data; delete temp; return data;&#125;bool queue::empty()&#123; return this-&gt;head-&gt;next == this-&gt;head;&#125;void RadixSort(int array[], int len)&#123; const int bucketCount = 10; queue *buckets = new queue[bucketCount]; int maxValue = array[0]; for (int i = 1; i &lt; len; i++) &#123; maxValue = max(maxValue, array[i]); &#125; int loopTime = log10(maxValue); for (int i = 0, power = 10; i &lt;= loopTime; i++, power *= 10) &#123; for (int j = 0; j &lt; len; j++) &#123; buckets[array[j] % power / (power / 10)].push(array[j]); &#125; for (int j = 0, k = 0; j &lt; bucketCount; j++) &#123; while (!buckets[j].empty()) &#123; array[k++] = buckets[j].pop(); &#125; &#125; &#125; delete[] buckets;&#125; 检测排序情况十大排序基本上就是以上的介绍了，在博主本人实际实现的过程中，为了检测排序结果是否正确，也为了调试上的方便，特地实现了一个小小的检测程序用来验证排序算法的准确性，也一并记录到最后。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990int *CreateArray(int len)&#123; static int *ret = nullptr; if (ret != nullptr) &#123; delete ret; &#125; ret = new int[len]; for (int i = 0; i &lt; len; i++) &#123; ret[i] = rand() % 10000; &#125; return ret;&#125;int *CopyArray(int *array, int len)&#123; int *ret = new int[len]; for (int i = 0; i &lt; len; i++) &#123; ret[i] = array[i]; &#125; return ret;&#125;bool CompArray(int array1[], int array2[], int len)&#123; for (int i = 0; i &lt; len; i++) &#123; if (array1[i] != array2[i]) &#123; return false; &#125; &#125; return true;&#125;void ShowArray(int array[], int len)&#123; for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; array[i] &lt;&lt; ","; &#125; cout &lt;&lt; endl;&#125;int main()&#123; int len; srand(time(NULL)); // srand(1); int T = rand() % 100 + 100; // int T = 1; while (T--) &#123; // len = 5; len = rand() % 10 + 1; int *array = CreateArray(len); // int array[] = &#123;3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48&#125;; // len = sizeof(array) / sizeof(array[0]); int *temp1 = CopyArray(array, len); int *temp2 = CopyArray(array, len); // BubbleSort(temp1, len); // SelectionSort(temp1, len); // InsertionSort(temp1, len); // ShellSort(temp1, len); // MergeSort(temp1, len); // QuickSort(temp1, len); // HeapSort(temp1, len); // CountingSort(temp1, len); // BucketSort(temp1, len); // RadixSort(temp1, len); sort(temp2, temp2 + len); if (!CompArray(temp1, temp2, len)) // if (true) &#123; ShowArray(array, len); ShowArray(temp1, len); ShowArray(temp2, len); cout &lt;&lt; endl; &#125; delete temp1; delete temp2; &#125; return 0;&#125; 完结撒花！！★,°:.☆(￣ ▽ ￣)/$:.°★]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>排序算法</tag>
        <tag>冒泡排序</tag>
        <tag>选择排序</tag>
        <tag>插入排序</tag>
        <tag>希尔排序</tag>
        <tag>归并排序</tag>
        <tag>快速排序</tag>
        <tag>堆排序</tag>
        <tag>计数排序</tag>
        <tag>桶排序</tag>
        <tag>基数排序</tag>
        <tag>递归</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构——堆栈]]></title>
    <url>%2F2019%2F02%2F15%2FDataStructurere-Stack%2F</url>
    <content type="text"><![CDATA[堆栈是一种先进后出的数据结构，我和别人说起来的时候，经常拿井做比较，最先放到井里的东西要最后才能拿出来。具体实现起来有着至少两种方式，链表实现和数组实现，实现思路都很简单，代码也都很简短。 堆栈 以下内容摘自维基百科 堆栈（英语：stack）又称为栈或堆叠，是计算机科学中一种特殊的串列形式的抽象资料型别，其特殊之处在于只能允许在连结串列或阵列的一端（称为堆叠顶端指标，英语：top）进行加入数据（英语：push）和输出数据（英语：pop）的运算 链表实现节点由于拿链表实现栈，因此最小单位是节点，使用一个结构来包装节点。 123456typedef struct Node&#123; ElementType data; struct Node *next;&#125; Node;typedef Node *Stack; 创建链表实现的栈本质上是一个有头结点的链表，因此，建立一个新栈就是申请一个节点的内存。 123456Stack CreateStack()&#123; Node *ret = (Node *)malloc(sizeof(Node)); ret-&gt;next = NULL; return ret;&#125; push向栈里 push 数据的话，其实就是在链表头再加一个节点。 1234567void Push(Stack stack, ElementType data)&#123; Node *temp = (Node *)malloc(sizeof(Node)); temp-&gt;data = data; temp-&gt;next = stack-&gt;next; stack-&gt;next = temp;&#125; pop与 push 相反，pop 是删除头节点后的第一个节点。 123456789void Pop(Stack stack)&#123; if (!Empty(stack)) &#123; Node *temp = stack-&gt;next; stack-&gt;next = temp-&gt;next; free(temp); &#125;&#125; toptop 的话，直接取出第一个节点的值 1234ElementType Top(Stack stack)&#123; return stack-&gt;next-&gt;data;&#125; empty想要检查栈是否为空，可以直接检查头结点后面有没有节点。 1234bool Empty(Stack stack)&#123; return stack-&gt;next == NULL;&#125; 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#define ElementType int#define bool int#define true 1#define false 0typedef struct Node&#123; ElementType data; struct Node *next;&#125; Node;typedef Node *Stack;Stack CreateStack()&#123; Node *ret = (Node *)malloc(sizeof(Node)); ret-&gt;next = NULL; return ret;&#125;bool Empty(Stack stack)&#123; return stack-&gt;next == NULL;&#125;void Push(Stack stack, ElementType data)&#123; Node *temp = (Node *)malloc(sizeof(Node)); temp-&gt;data = data; temp-&gt;next = stack-&gt;next; stack-&gt;next = temp;&#125;void Pop(Stack stack)&#123; if (!Empty(stack)) &#123; Node *temp = stack-&gt;next; stack-&gt;next = temp-&gt;next; free(temp); &#125;&#125;ElementType Top(Stack stack)&#123; return stack-&gt;next-&gt;data;&#125; 数组实现数组实现的思路有点像是做了个实实在在的井，容量有限，然后用记录下现在的元素数量，进而进行一系列操作。 结构用数组实现的栈已经不是一个简单的数据类型了，需要有个数组，还需要记录长度以及当前元素数量。因此使用结构表示，出于效率的考虑，最终决定使用结构指针。 1234567typedef struct&#123; ElementType *datas; int top; unsigned int length;&#125; Node;typedef Node *Stack; 创建与链表创建栈不同，数组版本的栈需要为其指定一个长度，然后申请对应大小的空间，同时初始化其他的元素。 12345678Stack CreateStack(const unsigned int length)&#123; Stack stack = (Node *)malloc(sizeof(Node)); stack-&gt;length = length; stack-&gt;top = 0; stack-&gt;datas = (ElementType *)malloc(length * sizeof(ElementType)); return stack;&#125; push向栈里 push 数据，相当与在数组当前记录过的元素后赋值，并更新top值。需要注意的是，此时要判断栈是否满。 1234567891011void Push(Stack stack, ElementType data)&#123; if (stack-&gt;top &lt; stack-&gt;length) &#123; stack-&gt;datas[++stack-&gt;top] = data; &#125; else &#123; exit(-1); &#125;&#125; pop数组版的pop只需要将top值减小就好。 1234567void Pop(Stack stack)&#123; if (!Empty(stack)) &#123; stack-&gt;top--; &#125;&#125; toptop的话，只需取出top值对应的元素即可。 1234ElementType Top(Stack stack)&#123; return stack-&gt;datas[stack-&gt;top];&#125; empty只要查看 top 的值即可确定是否为空栈 1234bool Empty(Stack stack)&#123; return stack-&gt;top == -1;&#125; 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#define ElementType int#define bool int#define true 1#define false 0typedef struct&#123; ElementType *datas; int top; unsigned int length;&#125; Node;typedef Node *Stack;Stack CreateStack(const unsigned int length)&#123; Stack stack = (Node *)malloc(sizeof(Node)); stack-&gt;length = length; stack-&gt;top = 0; stack-&gt;datas = (ElementType *)malloc(length * sizeof(ElementType)); return stack;&#125;bool Empty(Stack stack)&#123; return stack-&gt;top == -1;&#125;void Pop(Stack stack)&#123; if (!Empty(stack)) &#123; stack-&gt;top--; &#125;&#125;void Push(Stack stack, ElementType data)&#123; if (stack-&gt;top &lt; stack-&gt;length) &#123; stack-&gt;datas[++stack-&gt;top] = data; &#125;&#125;ElementType Top(Stack stack)&#123; return stack-&gt;datas[stack-&gt;top];&#125; 模板类实现最后贴上在 C++中包装成模板类的实现，仿照STL 中的 stack。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687template &lt;class T&gt;class Node&#123; public: T data; Node *next; Node(); Node(T data, Node *next = nullptr);&#125;;template &lt;class T&gt;class stack&#123; public: stack(); T top(); unsigned int size(); bool empty(); void push(T data); void pop(); private: Node&lt;T&gt; *datas; unsigned int length;&#125;;template &lt;class T&gt;Node&lt;T&gt;::Node(T data, Node *next)&#123; this-&gt;data = data; this-&gt;next = next;&#125;template &lt;class T&gt;Node&lt;T&gt;::Node()&#123; this-&gt;next = nullptr;&#125;template &lt;class T&gt;stack&lt;T&gt;::stack()&#123; this-&gt;datas = new Node&lt;T&gt;(); this-&gt;length = 0;&#125;template &lt;class T&gt;T stack&lt;T&gt;::top()&#123; if (!this-&gt;empty()) &#123; return this-&gt;datas-&gt;next-&gt;data; &#125; else &#123; exit(-1); &#125;&#125;template &lt;class T&gt;unsigned int stack&lt;T&gt;::size()&#123; return this-&gt;length;&#125;template &lt;class T&gt;bool stack&lt;T&gt;::empty()&#123; return this-&gt;datas-&gt;next == nullptr;&#125;template &lt;class T&gt;void stack&lt;T&gt;::push(T data)&#123; Node&lt;T&gt; *temp = new Node&lt;T&gt;(data, this-&gt;datas-&gt;next); this-&gt;datas-&gt;next = temp; this-&gt;length++;&#125;template &lt;class T&gt;void stack&lt;T&gt;::pop()&#123; Node&lt;T&gt; *temp = this-&gt;datas-&gt;next; this-&gt;datas-&gt;next = temp-&gt;next; delete temp; this-&gt;length--;&#125;]]></content>
      <categories>
        <category>基本数据结构的实现</category>
      </categories>
      <tags>
        <tag>《学习笔记》</tag>
        <tag>数据结构</tag>
        <tag>链表</tag>
        <tag>堆栈</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构——链表]]></title>
    <url>%2F2019%2F02%2F11%2FDataStructurere-LinkedList%2F</url>
    <content type="text"><![CDATA[数据结构是一个早就有所耳闻的东西，但是一直没有潜下心学习过，对数据结构的了解也仅限于 C++里的 STL，趁寒假有空闲，去听了浙江大学陈越老师的数据结构课程。当然，计算机领域的各种知识，只有亲自尝试了才能算是真的学得懂，因此，打算开个专题，将各个类型的数据结构都亲自实现一遍，并记录下来。 链表 以下内容摘自维基百科 链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到 O(1)的复杂度，但是查找一个节点或者访问特定编号的节点则需要 O(n)的时间。 使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。 实现本次实现是拿 C 语言实现的，但是因为个人编程习惯的原因，将 int 包装成了 bool 类型并使用。多数函数采用 bool 作为返回值，用于检查是否执行成功。 节点链表的一个很重要的特点是其结构由一些节点连接起来，各个节点是组成链表的最小单位。 一个节点由数据域和指针域组成，考虑用结构来表示。为表示方便，包装一个链表的数据类型。 123456typedef struct Node&#123; ElementType data; struct Node *next;&#125; Node;typedef Node *LinkList; 创建创建链表有两种基本的方式，分别是有头结点的链表和没有头结点的链表，在实际实现过程中，有头结点的链表实现起来更安全，也更加容易，因此采用有头结点的链表。 所以创建链表实际上就是建立了一个头结点，数据域不重要，指针域指向 NULL。 1234567LinkList CreateLink()&#123; //新建一个链表 LinkList link = (LinkList)malloc(sizeof(Node)); link-&gt;next = NULL; return link;&#125; 插入节点在索引为index的位置插入值为data的节点。 假设在索引为 (index-1) 的位置有节点node1，索引为 (index) 的位置有节点node2,则node1指向node2。 实现的思路是先新建一个节点node3,先让node3指向node2,然后让node1指向node3 12345678910111213141516171819202122bool InsertData(const LinkList linkList, unsigned const int index, const ElementType data)&#123; //在对应索引的位置插入节点 Node *iterator = linkList-&gt;next; int i = 0; for (; iterator; i++, iterator = iterator-&gt;next) &#123; if (i == index - 1) &#123; Node *node = (Node *)malloc(sizeof(Node)); if (node) &#123; node-&gt;data = data; node-&gt;next = iterator-&gt;next; iterator-&gt;next = node; return true; &#125; return false; &#125; &#125; return false;&#125; 删除节点删除索引为index的节点。 假设有连续三个节点node1，node2，node3，想要删除node2节点，只需要让node1的指针域指向node3，然后回收node2节点的内存即可。 1234567891011121314151617bool DeleteDataByIndex(const LinkList linkList, unsigned const int index)&#123; //删除对应索引的的节点 Node *beforeIterator = linkList; Node *deleteIterator = linkList-&gt;next; int i = 0; for (; deleteIterator; i++, beforeIterator = deleteIterator, deleteIterator = deleteIterator-&gt;next) &#123; if (i == index) &#123; beforeIterator-&gt;next = deleteIterator-&gt;next; free(deleteIterator); return true; &#125; &#125; return false;&#125; 修改节点修改索引为index的节点值为data。 基本思路来就是定位到索引的位置，然后修改具体的值。 123456789101112131415bool ChangeDataByIndex(const LinkList linkList, unsigned const int index, const ElementType data)&#123; //修改索引对应的节点 Node *iterator = linkList-&gt;next; int i = 0; for (; iterator; i++, iterator = iterator-&gt;next) &#123; if (i == index) &#123; iterator-&gt;data = data; return true; &#125; &#125; return false;&#125; 反转反转整条链表。 最开始我以为实现这个的做法改成双向链表，然后做标记，但后来才了解到,的确是一条单向链表的反转,而且实现过程相当巧妙。 基本思路是： 1. 用三个指针记录下连续的三个节点地址 2. 修改第二个节点的next使其指向第一个节点 3. 三个指针后移 4. 如果没有到达末尾，返回1 5. 修改头指针和第一个节点的next 6. 反转结束不过要注意的是，节点数较少时要做特殊处理。 1234567891011121314151617181920212223242526272829303132void ReverseLink(const LinkList linkList)&#123; //反转链表 Node *first = linkList-&gt;next; if (!first || !first-&gt;next) &#123; return; &#125; Node *second = first-&gt;next; if (!second-&gt;next) &#123; linkList-&gt;next = second; second-&gt;next = first; first-&gt;next = NULL; return; &#125; Node *third = second-&gt;next; while (true) &#123; second-&gt;next = first; first = second; second = third; if (!third) &#123; break; &#125; third = third-&gt;next; &#125; linkList-&gt;next-&gt;next = NULL; linkList-&gt;next = first;&#125; 排序将整条链排序 emm…，学习过之后才发现链表竟然如此神奇，本来我以为链表只能访问相邻的元素顶多就冒泡排序了。 结果，至少可以冒泡、选择、插入、快排、归并、希尔、堆排序等等…… 十大排序都可以用得上눈_눈 先贴上一位大佬的文章，本次排序的实现正是基于此篇文章。 点击前往大佬的文章 采取的是归并排序，这应该是最适合链表的排序方式了。 归并排序的第一步是将整个链表从中间分开，我当时还在想怎么可能定位到正中间，然后就被惊艳了。 定位的方法是快慢指针法，简单地说，使用两根指针同时从头出发，慢指针每次前进一个节点，快指针每次前进两个节点，这样，当快指针到达末尾的时候，慢指针差不多到达了一半的位置。 当定位到中点后，将一条链表劈成两半，分别递归排序两端链表(为了排序方便，使用没有头结点的链表)。 如果链表只有一个节点则自然有序 最后，将两条排好序的链表归并连接起来。相较于数组的归并排序，链表结构的独特性使得完全不用开辟额外空间。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576void SortLink(const LinkList linkList)&#123; //排序链表 //预处理成没有头结点的链表 linkList-&gt;next = MergeSort(linkList-&gt;next);&#125;Node *MergeSort(Node *begin)&#123; //归并排序 Node *fast = begin, *slow = begin; if (begin == NULL || begin-&gt;next == NULL) &#123; return begin; &#125; while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; fast = slow; fast-&gt;next = NULL; slow = slow-&gt;next; fast = MergeSort(begin); slow = MergeSort(slow); return Merge(fast, slow);&#125;Node *Merge(Node *first, Node *second)&#123; //合并两链表 Node *ret = NULL; Node *iterator = ret; while (first &amp;&amp; second) &#123; if (first-&gt;data &lt; second-&gt;data) &#123; if (iterator) &#123; iterator-&gt;next = first; iterator = iterator-&gt;next; first = first-&gt;next; &#125; else &#123; ret = first; iterator = first; first = first-&gt;next; &#125; &#125; else &#123; if (iterator) &#123; iterator-&gt;next = second; iterator = iterator-&gt;next; second = second-&gt;next; &#125; else &#123; ret = second; iterator = second; second = second-&gt;next; &#125; &#125; &#125; if (first) &#123; iterator-&gt;next = first; &#125; else &#123; iterator-&gt;next = second; &#125; return ret;&#125; 代码除此之外，再加一些简单的函数，全部代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ElementType int#define Out "%d"#define bool int#define true 1#define false 0typedef struct Node&#123; ElementType data; struct Node *next;&#125; Node;typedef Node *LinkList;LinkList CreateLink()&#123; //新建一个链表 LinkList link = (LinkList)malloc(sizeof(Node)); link-&gt;next = NULL; return link;&#125;bool AddDataAtLast(const LinkList linkList, const ElementType data)&#123; //在链表末尾增加一个节点 Node *last = linkList; while (last-&gt;next) &#123; last = last-&gt;next; &#125; last-&gt;next = (LinkList)malloc(sizeof(Node)); if ((last = last-&gt;next)) &#123; last-&gt;data = data; last-&gt;next = NULL; return true; &#125; return false;&#125;bool AddDataAtBegin(const LinkList linkList, const ElementType data)&#123; //在链表起始增加一个节点 Node *begin = linkList; Node *node = (Node *)malloc(sizeof(Node)); if (node) &#123; node-&gt;data = data; node-&gt;next = begin-&gt;next; begin-&gt;next = node; return true; &#125; return false;&#125;bool InsertData(const LinkList linkList, unsigned const int index, const ElementType data)&#123; //在对应索引的位置插入节点 Node *iterator = linkList-&gt;next; int i = 0; for (; iterator; i++, iterator = iterator-&gt;next) &#123; if (i == index - 1) &#123; Node *node = (Node *)malloc(sizeof(Node)); if (node) &#123; node-&gt;data = data; node-&gt;next = iterator-&gt;next; iterator-&gt;next = node; return true; &#125; return false; &#125; &#125; return false;&#125;bool DeleteDataByIndex(const LinkList linkList, unsigned const int index)&#123; //删除对应索引的的节点 Node *beforeIterator = linkList; Node *deleteIterator = linkList-&gt;next; int i = 0; for (; deleteIterator; i++, beforeIterator = deleteIterator, deleteIterator = deleteIterator-&gt;next) &#123; if (i == index) &#123; beforeIterator-&gt;next = deleteIterator-&gt;next; free(deleteIterator); return true; &#125; &#125; return false;&#125;bool DeleteDataByValue(const LinkList linkList, const ElementType data)&#123; //删除该值第一次出现的结点 Node *beforeIterator = linkList; Node *deleteIterator = linkList-&gt;next; for (; deleteIterator; beforeIterator = deleteIterator, deleteIterator = deleteIterator-&gt;next) &#123; if (deleteIterator-&gt;data == data) &#123; beforeIterator-&gt;next = deleteIterator-&gt;next; free(deleteIterator); return true; &#125; &#125; return false;&#125;bool ChangeDataByIndex(const LinkList linkList, unsigned const int index, const ElementType data)&#123; //修改索引对应的节点 Node *iterator = linkList-&gt;next; int i = 0; for (; iterator; i++, iterator = iterator-&gt;next) &#123; if (i == index) &#123; iterator-&gt;data = data; return true; &#125; &#125; return false;&#125;bool TryFindDataByValue(const LinkList linkList, const ElementType data, int *index)&#123; //查找该值第一次出现的节点的索引 Node *iterator = linkList-&gt;next; for ((*index) = 0; linkList; (*index)++, iterator = iterator-&gt;next) &#123; if (iterator-&gt;data == data) &#123; return true; &#125; &#125; (*index) = -1; return false;&#125;bool TryFindDataByIndex(const LinkList linkList, unsigned const int index, ElementType *data)&#123; //根据索引查找对应的值 Node *iterator = linkList-&gt;next; int i = 0; for (; iterator; i++, iterator = iterator-&gt;next) &#123; if (i == index) &#123; (*data) = iterator-&gt;data; return true; &#125; &#125; return false;&#125;void ReverseLink(const LinkList linkList)&#123; //反转链表 Node *first = linkList-&gt;next; if (!first || !first-&gt;next) &#123; return; &#125; Node *second = first-&gt;next; if (!second-&gt;next) &#123; linkList-&gt;next = second; second-&gt;next = first; first-&gt;next = NULL; return; &#125; Node *third = second-&gt;next; while (true) &#123; second-&gt;next = first; first = second; second = third; if (!third) &#123; break; &#125; third = third-&gt;next; &#125; linkList-&gt;next-&gt;next = NULL; linkList-&gt;next = first;&#125;void SortLink(const LinkList linkList)&#123; //排序链表 //预处理成没有头结点的链表 linkList-&gt;next = MergeSort(linkList-&gt;next);&#125;Node *MergeSort(Node *begin)&#123; //归并排序 Node *fast = begin, *slow = begin; if (begin == NULL || begin-&gt;next == NULL) &#123; return begin; &#125; while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; fast = slow; slow = slow-&gt;next; fast-&gt;next = NULL; fast = MergeSort(begin); slow = MergeSort(slow); return Merge(fast, slow);&#125;Node *Merge(Node *first, Node *second)&#123; //合并两链表 Node *ret = NULL; Node *iterator = ret; while (first &amp;&amp; second) &#123; if (first-&gt;data &lt; second-&gt;data) &#123; if (iterator) &#123; iterator-&gt;next = first; iterator = iterator-&gt;next; first = first-&gt;next; &#125; else &#123; ret = first; iterator = first; first = first-&gt;next; &#125; &#125; else &#123; if (iterator) &#123; iterator-&gt;next = second; iterator = iterator-&gt;next; second = second-&gt;next; &#125; else &#123; ret = second; iterator = second; second = second-&gt;next; &#125; &#125; &#125; if (first) &#123; iterator-&gt;next = first; &#125; else &#123; iterator-&gt;next = second; &#125; return ret;&#125;unsigned int LinkLength(const LinkList linkList)&#123; //返回链表的长度 Node *iterator = linkList-&gt;next; unsigned int i = 0; for (; iterator; i++, iterator = iterator-&gt;next) ; return i;&#125;void ShowLink(const LinkList linkList)&#123; //展示链表 Node *iterator = linkList-&gt;next; printf("Head =&gt; "); while (iterator) &#123; printf(Out " =&gt; ", iterator-&gt;data); iterator = iterator-&gt;next; &#125; printf("NULL\n");&#125;void ClearLink(const LinkList linkList)&#123; //清空链表 if (linkList-&gt;next) &#123; ClearLink(linkList-&gt;next); free(linkList-&gt;next); linkList-&gt;next = NULL; &#125; return;&#125; 留个空白，之后拿 C++封装成类再实现一遍。😁 模板类实现 2019 年 2 月 15 日更新 模仿STL 里的 List写的方法，为了实现一些功能硬是把单链表写成了双向链表，加上了头尾指针，心累 o(T ヘ To)，一些琐碎的细节折磨了很久(才没有去刷知乎(,,• ₃ •,,))，一天终于实现了，代码如下。(虽然还是有不安全的问题吧…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292template &lt;class T&gt;class Node&#123; public: Node(); Node(T data, Node *prev = nullptr, Node *next = nullptr); T data; Node *next, *prev;&#125;;template &lt;class T&gt;Node&lt;T&gt;::Node()&#123; this-&gt;next = nullptr; this-&gt;prev = nullptr;&#125;template &lt;class T&gt;Node&lt;T&gt;::Node(T data, Node *prev, Node *next)&#123; this-&gt;data = data; this-&gt;prev = prev; this-&gt;next = next;&#125;template &lt;class T&gt;class LinkList&#123; public: LinkList(); T front(); T back(); bool empty(); unsigned int size(); void clear(); void insert(int index, T data); void erase(int index); void push_front(T data); void push_back(T data); void pop_front(); void pop_back(); void reverse(); void sort(); private: Node&lt;T&gt; *head, *tail; unsigned int length; Node&lt;T&gt; *MergeSort(Node&lt;T&gt; *begin); Node&lt;T&gt; *Merge(Node&lt;T&gt; *first, Node&lt;T&gt; *second);&#125;;template &lt;class T&gt;LinkList&lt;T&gt;::LinkList()&#123; this-&gt;head = new Node&lt;T&gt;(); this-&gt;tail = new Node&lt;T&gt;(); this-&gt;head-&gt;next = tail; this-&gt;tail-&gt;prev = head; this-&gt;length = 0;&#125;template &lt;class T&gt;T LinkList&lt;T&gt;::front()&#123; return this-&gt;head-&gt;next-&gt;data;&#125;template &lt;class T&gt;T LinkList&lt;T&gt;::back()&#123; return this-&gt;tail-&gt;prev-&gt;data;&#125;template &lt;class T&gt;bool LinkList&lt;T&gt;::empty()&#123; return this-&gt;head-&gt;next == tail;&#125;template &lt;class T&gt;unsigned int LinkList&lt;T&gt;::size()&#123; return this-&gt;length;&#125;template &lt;class T&gt;void LinkList&lt;T&gt;::clear()&#123; Node&lt;T&gt; *temp = nullptr; for (Node&lt;T&gt; *iterator = this-&gt;head-&gt;next; iterator != this-&gt;tail;) &#123; temp = iterator; iterator = iterator-&gt;next; delete temp; &#125; this-&gt;head-&gt;next = this-&gt;tail; this-&gt;tail-&gt;prev = this-&gt;head;&#125;template &lt;class T&gt;void LinkList&lt;T&gt;::insert(int index, T data)&#123; Node&lt;T&gt; *iterator = this-&gt;head-&gt;next; for (int i = 0; iterator != this-&gt;tail; i++, iterator = iterator-&gt;next) &#123; if (i == index - 1) &#123; Node&lt;T&gt; *prev = iterator; Node&lt;T&gt; *next = iterator-&gt;next; Node&lt;T&gt; *temp = new Node&lt;T&gt;(data, prev, next); prev-&gt;next = temp; next-&gt;prev = temp; this-&gt;length++; return; &#125; &#125;&#125;template &lt;class T&gt;void LinkList&lt;T&gt;::erase(int index)&#123; Node&lt;T&gt; *iterator = this-&gt;head-&gt;next; for (int i = 0; iterator != this-&gt;tail; i++, iterator = iterator-&gt;next) &#123; if (i == index) &#123; Node&lt;T&gt; *prev = iterator-&gt;prev; Node&lt;T&gt; *next = iterator-&gt;next; prev-&gt;next = next; next-&gt;prev = prev; delete iterator; this-&gt;length--; return; &#125; &#125;&#125;template &lt;class T&gt;void LinkList&lt;T&gt;::push_front(T data)&#123; Node&lt;T&gt; *temp = new Node&lt;T&gt;(data, this-&gt;head, this-&gt;head-&gt;next); temp-&gt;prev-&gt;next = temp; temp-&gt;next-&gt;prev = temp; this-&gt;length++;&#125;template &lt;class T&gt;void LinkList&lt;T&gt;::push_back(T data)&#123; Node&lt;T&gt; *temp = new Node&lt;T&gt;(data, this-&gt;tail-&gt;prev, this-&gt;tail); temp-&gt;prev-&gt;next = temp; temp-&gt;next-&gt;prev = temp; this-&gt;length++;&#125;template &lt;class T&gt;void LinkList&lt;T&gt;::pop_front()&#123; Node&lt;T&gt; *temp = this-&gt;head-&gt;next; temp-&gt;prev-&gt;next = temp-&gt;next; temp-&gt;next-&gt;prev = temp-&gt;prev; delete temp; this-&gt;length--;&#125;template &lt;class T&gt;void LinkList&lt;T&gt;::pop_back()&#123; Node&lt;T&gt; *temp = this-&gt;tail-&gt;prev; temp-&gt;prev-&gt;next = temp-&gt;next; temp-&gt;next-&gt;prev = temp-&gt;prev; delete temp; this-&gt;length--;&#125;template &lt;class T&gt;void LinkList&lt;T&gt;::reverse()&#123; if (this-&gt;length == 0 || this-&gt;length == 1) &#123; return; &#125; else if (this-&gt;length == 2) &#123; T temp = this-&gt;head-&gt;next-&gt;data; this-&gt;head-&gt;next-&gt;data = this-&gt;tail-&gt;prev-&gt;data; this-&gt;tail-&gt;prev-&gt;data = temp; return; &#125; Node&lt;T&gt; *first = head-&gt;next; Node&lt;T&gt; *second = first-&gt;next; Node&lt;T&gt; *third = second-&gt;next; while (true) &#123; second-&gt;next = first; first-&gt;prev = second; first = second; second = third; if (third == this-&gt;tail) &#123; break; &#125; third = third-&gt;next; &#125; this-&gt;head-&gt;next-&gt;next = this-&gt;tail; this-&gt;tail-&gt;prev = this-&gt;head-&gt;next; this-&gt;head-&gt;next = first; first-&gt;prev = this-&gt;head;&#125;template &lt;class T&gt;void LinkList&lt;T&gt;::sort()&#123; this-&gt;head-&gt;next = MergeSort(head-&gt;next); for (Node&lt;T&gt; *iterator = this-&gt;head; iterator-&gt;next; iterator = iterator-&gt;next) &#123; iterator-&gt;next-&gt;prev = iterator; &#125;&#125;template &lt;class T&gt;Node&lt;T&gt; *LinkList&lt;T&gt;::MergeSort(Node&lt;T&gt; *begin)&#123; Node&lt;T&gt; *fast = begin, *slow = begin; if (begin == this-&gt;tail || begin-&gt;next == this-&gt;tail) &#123; return begin; &#125; while (fast-&gt;next != this-&gt;tail &amp;&amp; fast-&gt;next-&gt;next != this-&gt;tail) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; fast = slow; slow = slow-&gt;next; fast-&gt;next = this-&gt;tail; fast = MergeSort(begin); slow = MergeSort(slow); return Merge(fast, slow);&#125;template &lt;class T&gt;Node&lt;T&gt; *LinkList&lt;T&gt;::Merge(Node&lt;T&gt; *first, Node&lt;T&gt; *second)&#123; Node&lt;T&gt; *ret = nullptr; Node&lt;T&gt; *iterator = ret; while (first != this-&gt;tail &amp;&amp; second != this-&gt;tail) &#123; if (first-&gt;data &lt; second-&gt;data) &#123; if (iterator) &#123; iterator-&gt;next = first; iterator = iterator-&gt;next; first = first-&gt;next; &#125; else &#123; ret = first; iterator = first; first = first-&gt;next; &#125; &#125; else &#123; if (iterator) &#123; iterator-&gt;next = second; iterator = iterator-&gt;next; second = second-&gt;next; &#125; else &#123; ret = second; iterator = second; second = second-&gt;next; &#125; &#125; &#125; if (first != this-&gt;tail) &#123; iterator-&gt;next = first; &#125; else &#123; iterator-&gt;next = second; &#125; return ret;&#125;]]></content>
      <categories>
        <category>基本数据结构的实现</category>
      </categories>
      <tags>
        <tag>《学习笔记》</tag>
        <tag>数据结构</tag>
        <tag>链表</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《算法很美》——查找与排序（上）]]></title>
    <url>%2F2019%2F02%2F10%2FAlgorithmIsBeautifulul-SearchSortUp%2F</url>
    <content type="text"><![CDATA[第二章的内容相对第一章来说常规了一些，或者更应该说第一章的内容很是惊艳，毕竟位运算接触的少。而第二章分析算法的复杂度，排序算法的实现，二分查找这些就中规中矩了许多，在意的并不多。但是在例题里有几道感觉特别有意思的题目，思路比较巧，因此决定记下来。 设计一个高效的 pow 函数题目设计一个高效的求 a 的 n 次幂的算法，n 为正整数 思路这个题最朴素的思路自然是连续乘法，让 a 循环乘 n 次，即： 123456789int pow(int a, int n)&#123; int ret = 1; for (int i = 0; i &lt; n; i++) &#123; ret *= a; &#125; return ret;&#125; 教学过程中老师又提出了一种解法。 考虑到如果一个数和自己相乘，结果再和自己相乘，结果再乘，这样每次计算时所得的计算结果就会是原数的1,2,4,8,16,32次方，与连续乘的1,2,3,4,5相比快很多。当然，因为不连续的问题，会导致循环时有可能会跳过期望的 n，则可以将不足 n 的部分拿出单独按照同样的方法求。 任何一个十进制整数都可以被写成是二进制数，因此上述解法一定可以将 n 分解为若干个 2 的次幂相加，因此，该解法是正确无误的： 12345678910111213int pow(int a,int n)&#123; if(n==0) return 1; int res = a; int ex = 1; while((ex&lt;&lt;1)&lt;=n) &#123; res = res * res; ex &lt;&lt;= 1; &#125; return res * pow(a, n - ex);&#125; 只不过，看着这个解法，我总觉得还是有点不对劲。如果把 n 看作是 100，那么该解法相当于是分别求了n = 64，n = 32，n = 4时的情况，并将它们相乘，结果正确无误。 可是，在计算n = 64时，实际上是算过了n = 32以及n = 4的值，只是没有将它们用上而已，如此一来，这个解法应该还有继续优化的空间。 那么，如果可以将这个 n 分解开为若干个2 的次幂和的形式，然后在相乘的过程中遇见了这些次幂的情况就乘进结果中，最后再返回，那会不会就让整个过程更快了？ 那么，如何将一个 n 拆分成若干个 2 的次幂和的形式并将其记录下来呢？ 实际上，这一步计算机已经帮我们做好了。任意一个正整数数都可以被写成是二进制的形式，而计算机再内部储存数的时候采取的就是二进制。而二进制的每一位都有对应的权值，这些位上的数与它们的权值相乘求和就会得到所表达的二进制数。 也就是说，计算机在内部的二进制表示形式实际上就是我们希望的拆分并记录下的若干个 2 的次幂和的形式。 那么，接下来借用一下位运算的技巧，就可以写出解法。 12345678910111213int pow(int a, int n)&#123; int ret = 1; for (int power = a; n; n &gt;&gt;= 1) &#123; if (n &amp; 1) &#123; ret *= power; &#125; power *= power; &#125; return ret;&#125; 完美！(•̀ᴗ•́)و ̑̑ 走楼梯题目小明刚刚看完电影《第K级台阶》，离开电影院的时候，他数了数礼堂前的台阶数，恰好是K级! 站在台阶前，他突然又想着一个问题： 如果我每一步只能迈上1个或2个台阶。先迈左脚，然后左右交替，最后一步是迈右脚， 也就是说一共要走偶数步。那么，上完K级台阶，有多少种不同的上法呢？ 请你利用计算机的优势，帮助小明寻找答案。思路这道题有点斐波那契数列的感觉，但是加了一个条件，即考虑左右交替。 那么首先最朴素的想法就来了，和斐波那契数列一样，最简单的想法，第 n 阶偶数的方法数是第 n-1 阶奇数方法数与第 n-2 阶奇数的方法数之和，奇数同理，那么自然就有了如下的递归解法。 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int dfs(int k, int num, int ou)&#123; if (k == 0 &amp;&amp; (ou % 2 == 0)) &#123; num++; return num; &#125; else if (k &lt; 0 || (k == 0 &amp;&amp; ou % 2)) return num; num = dfs(k - 1, num, ou + 1); num = dfs(k - 2, num, ou + 1); return num;&#125;int main()&#123; int a; cin &gt;&gt; a; cout &lt;&lt; dfs(a, 0, 0) &lt;&lt; endl; return 0;&#125; 稍加改进 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int dfs(int k, bool even)&#123; if ((k == 1 &amp;&amp; even) || k == 2) &#123; return 1; &#125; else if (k &lt; 1 || (k == 1 &amp;&amp; !even)) &#123; return 0; &#125; return dfs(k - 1, !even) + dfs(k - 2, !even);&#125;int main()&#123; int a; cin &gt;&gt; a; cout &lt;&lt; dfs(a, false) &lt;&lt; endl;&#125; 欸，好像有点眼熟(○´･д･)ﾉ 如果把 return dfs(k - 1, !even) + dfs(k - 2, !even) 单独拿出来的话，不就是 dfs(k,even)=dfs(k - 1, !even) + dfs(k - 2, !even) 了嘛，如果再加上初始条件和记录的数组的话。 all[i][j] = all[i - 1][!j] + all[i - 2][!j] 和斐波那契数列好像哦 Fib[i] = Fib[i-1] + Fib[i - 2] 所以这道题实际上是动态规划 🤣，状态转移方程就是之前写下的样子。 改为动态规划后的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;const int maxn = 25;long long all[maxn][2];const int Left = 0, Right = 1;const int Impossible = -1;int main()&#123; all[1][Left] = 1; all[2][Left] = 1; all[1][Right] = Impossible; all[2][Right] = 1; for (int i = 3; i &lt; maxn; i++) &#123; for (int j = Left; j &lt;= Right; j++) &#123; if (all[i - 1][!j] != Impossible) &#123; all[i][j] += all[i - 1][!j]; &#125; if (all[i - 2][!j] != Impossible) &#123; all[i][j] += all[i - 2][!j]; &#125; if (!all[i][j]) &#123; all[i][j] = Impossible; &#125; &#125; &#125; int k; cin &gt;&gt; k; cout &lt;&lt; all[k][Right] &lt;&lt; endl; return 0;&#125; 好吧，这是我第一次看出来是动态规划并且推出状态转移方程的题，所以拿出来纪念下(｡◕ˇ∀ˇ◕）。 就写这么多吧，剩下的内容感觉比较简单就不写了。😁]]></content>
      <categories>
        <category>《算法很美》</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>学习笔记</tag>
        <tag>《算法很美》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《算法很美》——位运算的奇巧淫技]]></title>
    <url>%2F2019%2F02%2F07%2FAlgorithmIsBeautifulul-BitwiseOperation%2F</url>
    <content type="text"><![CDATA[寒假前报名了蓝桥杯，和同学一起参加了蓝桥杯 《算法很美》的课程，于是开了个新坑，学习一些基本的算法知识。 位操作 摘自维基百科 取反(NOT)取反是一元运算符，对一个个二进制数的每一位执行逻辑反操作，是数字1成为0，数字0成为1。例如： NOT 0111 = 1000 在C/C++程序设计语言中，取反操作通过波浪线“~”来表示。 按位或(OR)按位或处理两个长度相同的二进制数，两个相应的二进位中只要有一个为1，该位的结果值为1。例如： 0010 OR 1000 = 1010 在C/C++程序设计语言中，按位或操作通过单竖线“|”来表示。 按位异或(XOR)按位异或对等长二进制模式或二进制数的每一位执行逻辑异或操作。操作结果是如果某位不同则改为为1，否则改为为0。例如： 0101 XOR 0011 = 0110 在C/C++程序设计语言中，按位异或的运算符是“^”。 按位与(AND)按位与处理两个长度相同的二进制数，两个相应的二进位都为1，改为的结果值才为1，否则为0。例如： 0101 AND 0011 = 0001 在C/C++程序设计语言中，按位与的运算符是“&amp;”。 移位移位是一个二元运算符，用来将一个二进制数的每一位全部都向一个方向移动指定为，溢出的部分将被舍弃，而孔雀的部分填入0。例如： 0001 &lt;&lt; 3 = 1000 1010 &gt;&gt; 2 = 0010 在C/C++程序设计语言中，移位的运算符是“&lt;&lt;”与“&gt;&gt;”。 应用1. 判断奇偶数题目任给一个整数n，判断该数是否为奇数。 定义判断 可以被2整除的数是偶数，不可被2整除的数是奇数 12345678bool IsOdd(int n)&#123; if (n % 2 == 0) &#123; return false; &#125; return true;&#125; 使用位运算“&amp;” 奇数的二进制形式最后一位是1，偶数则为0 按位与处理两个长度相同的二进制数，两个相应的二进位都为1，改为的结果值才为1，否则为0 因此，任意一个整数n与整数1进行与操作时，若n二进制形式最低为为1则结果为1，否则为0。 12345678bool IsOdd(int n)&#123; if (n &amp; 1) &#123; return true; &#125; return false;&#125; 验证程序123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;bool IsOdd(int n);int main()&#123; int n; cout &lt;&lt; "请输入一个整数:" &lt;&lt; endl; cin &gt;&gt; n; if (IsOdd(n)) &#123; cout &lt;&lt; n &lt;&lt; "是奇数。" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; n &lt;&lt; "不是奇数。" &lt;&lt; endl; &#125; return 0;&#125; 2.找出唯一成对的数题目1-n这n个数放在含有(n+1)个元素的数组中，只有唯一的一个元素值重复，其它的均只出现一次。每个数组元素只能访问一次，设计一个算法，将它找出来。如果不使用存储空间，能否设计一个算法实现？ 计数(需要辅助空间)可以记下每个数字出现的次数，然后找到出现两次的数。 123456789101112131415161718192021int PairNumber(int *arr, int n)&#123; int *bucket = new int[n]; memset(bucket, 0, n * sizeof(bucket[0])); //记录下每个数出现的次数，保存到对应下标下 for (int i = 0; i &lt;= n; i++) &#123; bucket[arr[i]]++; &#125; //遍历查找出现两次的数 for (int i = 0; i &lt; n; i++) &#123; if (bucket[i] == 2) &#123; return i; &#125; &#125; return -1;&#125; 异或去除重复(偶数次)项 两个相同的数进行异或，结果是0 如果对一系列数进行异或，可以消除掉重复出现偶数次的数 将原数组的数异或一边后，再与1-n异或一边，则重复出现两次的数被异或了三次，其余的数被异或了两次被消去，因此最终结果就是原数组中出现两次的数 1234567891011121314151617int PairNumber(int *arr, int n)&#123; int ret = 0; //遍历异或原数组 for (int i = 0; i &lt;= n; i++) &#123; ret ^= arr[i]; &#125; //与1-n异或 for (int i = 1; i &lt;= n; i++) &#123; ret ^= i; &#125; return ret;&#125; 验证程序12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;cstring&gt;using namespace std;int PairNumber(int *arr, int n);int main()&#123; int n; cout &lt;&lt; "请输入n:" &lt;&lt; endl; cin &gt;&gt; n; //构造长度为(n+1)的数组 int *arr = new int[n + 1]; for (int i = 0; i &lt; n; i++) &#123; arr[i] = i + 1; &#125; srand((int)time(NULL)); arr[n] = (int)(rand() * 1.0 / RAND_MAX * (n - 1) + 1); //打乱数组 for (int i = 0; i &lt;= n; i++) &#123; swap(arr[i], arr[(int)(rand() * 1.0 / RAND_MAX * n)]); &#125; //输出结果 cout &lt;&lt; "原数组为：" &lt;&lt; endl; for (int i = 0; i &lt;= n; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; "重复出现的数为：" &lt;&lt; PairNumber(arr, n) &lt;&lt; endl; return 0;&#125; 3.找出落单的数题目一个长度为(2×n+1)的数组里除了某一个数字之外，其它的数字都出现了两次，请写出程序找出这个只出现了一次的数字。 异或去重思路与上题类似，通过遍历异或消去重复出现两次的数。 123456789int SingleNumber(int *arr, int n)&#123; int ret = 0; for (int i = 0; i &lt; n; i++) &#123; ret ^= arr[i]; &#125; return ret;&#125; 验证程序12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;using namespace std;int SingleNumber(int *arr, int n);int main()&#123; int n; cout &lt;&lt; "请输入n:" &lt;&lt; endl; cin &gt;&gt; n; //构造长度为(2×n+1)的数组 srand((int)time(NULL)); int *arr = new int[2 * n + 1]; for (int i = 0; i &lt; n; i++) &#123; arr[i] = arr[i + n] = rand(); &#125; arr[2 * n] = rand(); //打乱数组 int len = 2 * n + 1; for (int i = 0; i &lt; len; i++) &#123; swap(arr[i], arr[(int)(rand() * 1.0 / RAND_MAX * len)]); &#125; //输出结果 cout &lt;&lt; "原数组为：" &lt;&lt; endl; for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; "出现一次的数为：" &lt;&lt; SingleNumber(arr, len) &lt;&lt; endl; return 0;&#125; 4.找出两个落单的数题目一个长度为(2×n+2)的数组里除了某两个个数字之外，其它的数字都出现了两次，请写出程序找出这两个只出现了一次的数字。 三次异或可知如果用0和所有的数都异或一遍，可以的到没有重复的两个数异或的结果。 因为这两个数并不相同，所以得到的结果必定不是0，即所得结果二进制中必定存在至少一个1。 根据异或的性质可知，这两个数在这一位的数一定不相同，一个是1，而另一个是0。那么，如果将所有该位是1的数与所有该位都是0的数分别异或，所得结果就是这两个数。 123456789101112131415161718192021222324252627282930pair&lt;int, int&gt; SingleNumbers(int *arr, int n)&#123; int first = 0, second = 0; int temp = 0; for (int i = 0; i &lt; n; i++) &#123; temp ^= arr[i]; &#125; int flag = 0; for (int i = 0;; i++) &#123; if (temp &amp; (1 &lt;&lt; i)) &#123; flag = 1 &lt;&lt; i; break; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (arr[i] &amp; flag) &#123; first ^= arr[i]; &#125; else &#123; second ^= arr[i]; &#125; &#125; return make_pair(first, second);&#125; 验证程序12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;utility&gt;using namespace std;pair&lt;int, int&gt; SingleNumbers(int *arr, int n);int main()&#123; int n; cout &lt;&lt; "请输入n:" &lt;&lt; endl; cin &gt;&gt; n; //构造长度为(2×n+2)的数组 srand((int)time(NULL)); int *arr = new int[2 * n + 2]; for (int i = 0; i &lt; n; i++) &#123; arr[i] = arr[i + n] = rand(); &#125; arr[2 * n] = rand(); arr[2 * n + 1] = arr[2 * n] + rand(); //打乱数组 int len = 2 * n + 2; for (int i = 0; i &lt; len; i++) &#123; swap(arr[i], arr[(int)(rand() * 1.0 / RAND_MAX * len)]); &#125; //输出结果 cout &lt;&lt; "原数组为：" &lt;&lt; endl; for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; pair&lt;int, int&gt; ans = SingleNumbers(arr, len); cout &lt;&lt; "出现一次的数为：" &lt;&lt; ans.first &lt;&lt; "与" &lt;&lt; ans.second &lt;&lt; endl; return 0;&#125; 5.二进制中1的个数题目给定一个整数n，输出该数二进制表示中1的个数。 与做法之一 两个二进制数按位与，若相同位相同，则结果为1，否则为0 让一个只有最低位为1的二进制与原数与，然后不断左移，如果结果不为0则说明该位是1。 1234567891011121314int CountOneinBit(int n)&#123; int size = sizeof(n) * CHAR_BIT; int ret = 0, temp = 1; for (int i = 0; i &lt; size;i++) &#123; if(n&amp;temp) &#123; ret++; &#125; temp &lt;&lt;= 1; &#125; return ret;&#125; 与做法之二与做法一类似，但是改为将原数右移和1进行与运算 12345678910111213int CountOneinBit(int n)&#123; int ret = 0; for (int i = 0; n; i++) &#123; if (1 &amp; n) &#123; ret++; &#125; n &gt;&gt;= 1; &#125; return ret;&#125; 与做法之三 对于整数n，n&amp;(n-1)的结果是消除掉n二进制形式的最后一个。 不断消除整数二进制形式的最后一个1，直到原数变成0，则消除的次数就是1的个数 12345678910int CountOneinBit(int n)&#123; int ret = 0; for (int i = 0; n; i++) &#123; n = n &amp; (n - 1); ret++; &#125; return ret;&#125; 验证程序1234567891011121314#include &lt;iostream&gt;using namespace std;int CountOneinBit(int n);int main()&#123; int n; cout &lt;&lt; "请输入一个整数n：" &lt;&lt; endl; cin &gt;&gt; n; cout &lt;&lt; n &lt;&lt; "的二进制形式中1的个数是：" &lt;&lt; CountOneinBit(n) &lt;&lt; endl; return 0;&#125; 6.判断一个整数是否为2的整数次方题目使用一条语句判断一个整数是否为2的整数次方 与做法易知如果一个数的二进制形式中只有一个1，则符合题意，考虑上题第三种解法，可得： 1234bool IsIntegerPowerof2(int n)&#123; return !(n &amp; (n - 1));&#125; 验证程序12345678910111213141516171819#include &lt;iostream&gt;using namespace std;bool IsIntegerPowerof2(int n);int main()&#123; int n; cout &lt;&lt; "请输入一个整数n：" &lt;&lt; endl; cin &gt;&gt; n; cout &lt;&lt; n; if (!IsIntegerPowerof2(n)) &#123; cout &lt;&lt; "不"; &#125; cout &lt;&lt; "是2的整数次幂。" &lt;&lt; endl; return 0;&#125; 7.将整数的奇偶位互换题目将一个整数n的二进制形式下的奇数位与偶数位互换。 拆分，移位，异或具体思路如下图： 将奇位与偶位拆分开，通过移位后再次组合在一起 123456int SwapOddEven(int n)&#123; int even = n &amp; 0xaaaaaaaa;//10101010.... int odd = n &amp; 0x55555555;//01010101.... return (even &gt;&gt; 1) ^ (odd &lt;&lt; 1);&#125; 验证程序1234567891011121314#include &lt;iostream&gt;using namespace std;int SwapOddEven(int n)；int main()&#123; int n; cout &lt;&lt; "请输入一个整数n：" &lt;&lt; endl; cin &gt;&gt; n; cout &lt;&lt; n &lt;&lt; "的奇偶位互换后是" &lt;&lt; SwapOddEven(n) &lt;&lt; endl; return 0;&#125; 8.出现k次与出现1次题目数组中只有一个数出现了1次，其它的数都出现了k次，请输出只出现了1次的数。 k进制不进位加法 k个相同的k进制数之和为0 老实说这个解法不算很简洁，但是很独特。将所有的数转化为k进制，然后进行不进位加法，则最终的结果就是只出现了一次的数的k进制，再转回去就好。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071const int maxn = 1e3 + 10;//将两个k进制数进行不进位相加string noCrashSum(string kRadix1, string kRadix2, int k)&#123; reverse(kRadix1.begin(), kRadix1.end()); reverse(kRadix2.begin(), kRadix2.end()); int len = max(kRadix1.length(), kRadix2.length()); while (kRadix1.length() &lt; len) &#123; kRadix1 += "0"; &#125; while (kRadix2.length() &lt; len) &#123; kRadix2 += "0"; &#125; string ret; for (int i = 0; i &lt; len; i++) &#123; ret += ((kRadix1[i] - '0' + kRadix2[i] - '0') % k + '0'); &#125; reverse(ret.begin(), ret.end()); return ret;&#125;//计算长度为n的k进制数组的不进位和string noCrashSum(string kRadixs[], int n, int k)&#123; string ret; for (int i = 0; i &lt; n; i++) &#123; ret = noCrashSum(ret, kRadixs[i], k); &#125; return ret;&#125;//将十进制整数n转化为k进制字符串string ToString(int n, int k)&#123; string ret = ""; do &#123; ret += (n % k + '0'); n /= k; &#125; while (n); return ret;&#125;//将k进制数kRadix转化为十进制整数int ToInt(string kRadix, int k)&#123; reverse(kRadix.begin(), kRadix.end()); int ret = 0; for (int i = 0; i &lt; kRadix.length(); i++) &#123; ret = ret * k + (kRadix[i] - '0'); &#125; return ret;&#125;//求在长度n的数组中，只出现一次的数int SingleNumber(int *arr, int n, int k)&#123; string kRadixs[maxn]; for (int i = 0; i &lt; n; i++) &#123; kRadixs[i] = ToString(arr[i], k); &#125; string kRadixAns = noCrashSum(kRadixs, n, k); return ToInt(kRadixAns, k);&#125; 验证程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;array&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;#include &lt;cstdlib&gt;using namespace std;const int maxn = 1e3 + 10;//将两个k进制数进行不进位相加string noCrashSum(string kRadix1, string kRadix2, int k);//计算长度为n的k进制数组的不进位和string noCrashSum(string kRadixs[], int n, int k);//将十进制整数n转化为k进制字符串string ToString(int n, int k);//将k进制数kRadix转化为十进制整数int ToInt(string kRadix, int k);//求在长度n的数组中，只出现一次的数int SingleNumber(int *arr, int n, int k);int main()&#123; int n, k; cout &lt;&lt; "Tip: n × k &lt; " &lt;&lt; maxn &lt;&lt; endl; cout &lt;&lt; "请输入一个n：" &lt;&lt; endl; cin &gt;&gt; n; cout &lt;&lt; "请输入一个k：" &lt;&lt; endl; cin &gt;&gt; k; int len = n * k + 1; //生成数组 int *arr = new int[len]; srand(time(NULL)); for (int i = 0; i &lt; n; i++) &#123; int value = rand(); for (int j = 0; j &lt; k; j++) &#123; arr[i + n * j] = value; &#125; &#125; arr[len - 1] = rand(); //打乱数组 for (int i = 0; i &lt; len; i++) &#123; swap(arr[i], arr[(int)(rand() * 1.0 / RAND_MAX * len)]); &#125; cout &lt;&lt; "原数组为：" &lt;&lt; endl; for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; "出现一次的数是：" &lt;&lt; SingleNumber(arr, len, k) &lt;&lt; endl; return 0;&#125; 总结本次课程的内容就像是题目所说的“奇巧淫技”，本来对位运算了解并不多，也不怎么会用，而这次见识到的这些神奇的操作则是刷新了我对位运算的看法，体会到了算法的神奇巧妙之处。]]></content>
      <categories>
        <category>《算法很美》</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>学习笔记</tag>
        <tag>《算法很美》</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一次对内存的探索]]></title>
    <url>%2F2018%2F12%2F13%2FExploreByte%2F</url>
    <content type="text"><![CDATA[一段程序故事发生在某天深夜，已经熄灯的宿舍，黯淡的屏幕闪烁出一条消息 “睡了没” “木呢。” “来看段代码” 12345678910#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int i= 17970; char *q = &amp;i; printf("%d\n", *q); printf("%d\n", *(q + 1)); return 0;&#125; “……，这啥操作？” “输出是 50 70。” 简单总结下这段代码奇怪的地方 使用一个*char** 指针指向了一个 int 类型的整数; 将*char** 指针所指内容强制转化为 int 类型输出; 和 2 扯不断的联系 “一个突破口是 17970 % 256 = 50,17970 / 256 = 70 。” 256是个很眼熟的数字，对于程序员来说，最直接联想到的就是2 ^ 8 = 256。这个2很是让人在意，计算机总是离不开二进制，在这里，一个涉及指针的程序突然出现了2，这就不得不让人联想到使用二进制进行进一步探索。 使用 unionunion是 C 语言里一个比较奇特的关键字，其使用方式和struct很是相似。区别在于struct中各个元素是相互独立的，互相之间不会有影响，而union则只分配一块内存，各个成员共用同一块内存空间。 比如说，对于以下代码： 12345678910union UN&#123; int a; char ch[4];&#125;struct Temp&#123; int a; char ch[4];&#125; union struct 那么使用 union 就可以模仿上述代码中用 char 的方式访问 int。 首先用下述程序验证一下： 123456789101112131415161718192021#include &lt;stdio.h&gt;typedef union UN&#123; int a; char ch[4];&#125; UN;int main()&#123; UN un; un.a = 17970; int i = 0; printf("%d\n", un.a); for (;i&lt;4;i++) &#123; printf("%d ", un.ch[i]); &#125; printf("\n"); return 0;&#125; 结果和预想一致：1797050 70 0 0 结合二进制那么将上述程序稍加修改，以二进制形式输出呢？ 1234567891011121314151617181920212223242526272829303132333435363738void int2Binary(int temp)&#123; char str[33] = &#123;0&#125;; memset(str, '0', sizeof(str) - 1); int i = 31; do &#123; str[i--] = temp % 2 + '0'; temp /= 2; &#125; while (temp); printf("%s\n", str);&#125;void char2Binary(char temp)&#123; char str[9] = &#123;0&#125;; memset(str, '0', sizeof(str) - 1); int i = 7; do &#123; str[i--] = temp % 2 + '0'; temp /= 2; &#125; while (temp); printf("%s\n", str);&#125;int main()&#123; UN un; un.a = 17970; int i = 0; int2Binary(un.a); for (; i &lt; 4; i++) &#123; char2Binary(un.ch[i]); &#125; return 0;&#125; 输出结果为：0000000000000000010001100011001000110010010001100000000000000000稍加思索 (￣.￣) 整理下形式00000000 00000000 01000110 0011001000110010 01000110 00000000 00000000≖‿≖✧ 可以看到，如果将一个 int 放大到内存去看的话，四个字节的排列方式是低权位在前，高权位在后，这点颠覆了我过往的认知。 其次，在这里我突然明白了为什么2 ^ 8 = 256里这个8的含义，每个字节占8位，2与8的结合产生出了256这个神奇的数字。 答案 “也就是说，char*的作用是将 int 的一部分拿出来，再强制转化为 int 进行操作。” “而一个 int 占四个字节，char 占一个字节，刚好能拿出四分之一” “一个字节占 8 位，这就是 256 的原因。” “最为关键的是，int 在内存中的存放方式是以一个字节为单位，低权位在后，高权位在前，这就是为什么是 50 和 70 而不是两个 0。” “完美。” “睡觉。” 加戏如果说一个可以用 char 来逐字节的读 int 的话，那么换成其他的类型应该也是没问题的吧。 或者从原理上讲，从 int 的首地址出发，使用 char 将其向后 sizeof(int) 的内存中的内容读了出来。 那么，如果已知一个地址，使用类似的思路，是不是就能将其之后指定大小的内存中的内容读出来了？ 按着这个想法对之前的函数稍加修改，于是就得到了一个查看内存内容的工具。 (•̀ᴗ•́)و ̑̑ 两个参数分别是地址以及大小，返回的是以 C 风格的字符串储存的该内存中的内容。 1234567891011121314151617181920212223242526272829char *ToBinary(const char *source, const unsigned int size)&#123; unsigned ret_length = size * (CHAR_BIT + 1); char *_source = (char *)malloc(sizeof(char) * size); memcpy(_source, source, size); //使用_source代替source static char *ret = NULL; //返回ret if (ret) &#123; free(ret); &#125; ret = (char *)malloc(sizeof(char) * ret_length + 1); ret[sizeof(char) * ret_length] = 0; //最后一个是0 for (int index = 0; index &lt; size; index++) &#123; short char_source = *(_source + index); char *temp = ret + index * (CHAR_BIT + 1); memset(temp, '0', sizeof(char) * CHAR_BIT); temp[CHAR_BIT] = ' '; for (int j = CHAR_BIT - 1; j &gt;= 0; j--) &#123; temp[j] = (char_source &amp; 1) + '0'; char_source &gt;&gt;= 1; &#125; &#125; return ret;&#125; 有意思的事情要发生了。 左移与右移C 语言中的 &lt;&lt; 与 &gt;&gt; 是两个比较神奇的操作符，能将一个数从内存中左移或者右移。本来潜意识里我认为就是直接移就好了。但是之前也有发现，int 在内存中的储存方式并不是一个连续的状态，而是每八个字节为一个单位，低权位在前，高权位在后。那左移和右移究竟是如何进行的呢？用上之前的函数，写个程序看看： 12345678910int main()&#123; int x = 1; while(x&gt;0) &#123; printf("%s\n", ToBinary((char *)&amp;x, sizeof(x))); x &lt;&lt;= 1; &#125; return 0;&#125; 结果如下： 00000001 00000000 00000000 0000000000000010 00000000 00000000 0000000000000100 00000000 00000000 0000000000001000 00000000 00000000 0000000000010000 00000000 00000000 0000000000100000 00000000 00000000 0000000001000000 00000000 00000000 0000000010000000 00000000 00000000 0000000000000000 00000001 00000000 0000000000000000 00000010 00000000 0000000000000000 00000100 00000000 0000000000000000 00001000 00000000 0000000000000000 00010000 00000000 0000000000000000 00100000 00000000 0000000000000000 01000000 00000000 0000000000000000 10000000 00000000 0000000000000000 00000000 00000001 0000000000000000 00000000 00000010 0000000000000000 00000000 00000100 0000000000000000 00000000 00001000 0000000000000000 00000000 00010000 0000000000000000 00000000 00100000 0000000000000000 00000000 01000000 0000000000000000 00000000 10000000 0000000000000000 00000000 00000000 0000000100000000 00000000 00000000 0000001000000000 00000000 00000000 0000010000000000 00000000 00000000 0000100000000000 00000000 00000000 0001000000000000 00000000 00000000 0010000000000000 00000000 00000000 01000000可以看到，在一个字节中，左移 的确是不断向左移动，但是字节与字节之间来看，则是有些奇怪的样子。 看样子说成左移和右移更多的是考虑到的是易于理解，而实际上并不是简单的左移和右移。虽然并不是很理解为什么要这样设计内存的使用方式就是了。 结构(struct)之前有次时间探寻了一下结构的size的问题，发现了一个有些神奇的规律。 设结构内各个元素的 size 之和为x，结构内最大的元素 size 为y，结构的 size 为z,则满足z &gt;= x &amp;&amp; z % y == 0。老师解释多的那部分是记录了结构的一些东西。 但是，果然还是自己看看才放心啊。&lt;(￣︶￣)&gt; 实验程序如下。 12345678910111213141516171819202122232425262728293031323334353637typedef struct&#123; char a;&#125; A;typedef struct&#123; char a; int b;&#125; B;typedef struct&#123; char a; int b; long long c;&#125; C;typedef struct&#123; char a; long long c;&#125; D;int main()&#123; A a; B b; C c; D d; d.a = c.a = b.a = a.a = CHAR_MAX; c.b = b.b = INT_MAX; d.c = c.c = LONG_LONG_MAX; printf("%s\n", ToBinary((char *)&amp;a, sizeof(a))); printf("%s\n", ToBinary((char *)&amp;b, sizeof(b))); printf("%s\n", ToBinary((char *)&amp;c, sizeof(c))); printf("%s\n", ToBinary((char *)&amp;d, sizeof(d))); return 0;&#125; 输出如下： 01111111 01111111 00000000 00000000 00000000 11111111 11111111 11111111 01111111 01111111 00000000 00000000 00000000 11111111 11111111 11111111 01111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 01111111 01111111 00000000 00000000 00000000 00000000 00000000 00000000 00000000 11111111 11111111 11111111 11111111 11111111 11111111 11111111 01111111 所以多出来的那一部分里面什么都没有（°ο°） 好吧，还是很好奇为什么要设计成这个样子。 结语在 struct 之后，我又分别测试了 union 和 class 都和想象的差不多，就不说了。但是最后我又发现了个好玩的东西。 我记得，函数入口是个指针吧。 那么最后这个程序呢？ 12345678910111213141516171819void fun1()&#123;&#125;void fun2()&#123; int a = 0;&#125;void fun3()&#123;&#125;int main()&#123; printf("%s\n", ToBinary((char *)fun1, (char *)fun2 - (char *)fun1)); printf("%s\n", ToBinary((char *)fun2, (char *)fun3 - (char *)fun2)); return 0;&#125; 反正是超出了我的知识范围 ╮(╯▽╰)╭ 滚回去复习期末考试~(～ o ￣ ▽ ￣)～ o]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>union</tag>
        <tag>struct</tag>
        <tag>左移与右移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用VScode编写C++文件]]></title>
    <url>%2F2018%2F12%2F01%2Fc-withVScode%2F</url>
    <content type="text"><![CDATA[第一次接触visual studio code是在大一上学期，正是初学C语言的时候。那时候老师与学长推荐的集成开发环境（IDE）主要是Dev C++与code block，这两款IDE的优点是简单，小巧，可以很快速的使代码运行起来，但他们都有很致命的缺点，就是界面不够美观，虽然在网上都能找到一些教程对其进行美化，但能做到的也只是不再难看而已，与真正做到好看相比还差的很远。 恰巧那段时间因为学习前端的知识而了解到VS code这款编辑器，同样是写代码，利用VS code写HTML，CSS，JavaScript比用code block写C体验好多了，而也惊喜的发现，VS code支持书写C/C++程序\(≧▽≦)/，于是就想使用VS code编写C程序，但当时不明白VS code只是一个编辑器且不带编译器，并不能直接编译，运行C程序，而且在查看一些C文件时会出现乱码现象一脸懵逼(o゜▽゜)o☆（当时并不知道时编码的问题），于是在查找了众多资料无果后只好放弃〒▽〒。 时过境迁，一年的学习，学习的语言由简单的C拓展到C++，JAVA，C#等多种语言，编程的模式由简单的面向过程到C++式的多种模式混合，C#窗口的事件-响应函数，unity的逐帧调用等多种模式，知识储备量有了一定的提升(●ˇ∀ˇ●)，再回过头来，依旧还是想用VS code编写C/C++程序，于是在某一天，一句一句看懂了官网的文档，一步一步调试，终于在最后调试成功(´▽`ʃ♡ƪ)！经过了一段时间的使用，体验还算不错，在这里记下环境配置的方法，也记录下自己的小小激动。 Tip: 本次记录的是在Windows10下搭建的环境(Linux下的还没折腾出来◑﹏◐) 2018年12月30日更新：经过一段时间折腾，发现了其它使用VS code进行C/C++编程的方法，已经整合在了原文中。 配置方法安装 Visual Studio Code最开始的步骤当然时安装VS code啦，进入官网，点击很显眼的 Download 按钮，下载VS code。值得一提的是，点击下载之后网页会自动跳转到VS code的文档界面，在这里会很方便的找到如何配置各种语言环境的说明，写的也都比较详细，是本次配置的主要参考资料。 安装 Microsoft C/C++ extension首先安装 Microsoft C/C++ extension，这是微软自家研发的VS code插件，内置了编写C++的众多工具。 打开VS code 点击左侧侧边栏的扩展图标或者使用快捷键ctrl+shift+x打开扩展界面 在搜索框搜索C++寻找Microsoft C/C++ extension。 点击安装，安装结束后点击重载 安装MinGW-w64MinGW-w64是著名C/C++编译器GCC的Windows版本，是VS code官网推荐在Windows上使用的编译器（虽然官网在这里直接略过了( ˉ ▽ ˉ；)…）。 在网上找到了一篇介绍非常详细的博客《⑨也懂系列：MinGW-w64安装教程》,然后是MinGW-w64的官方网址,貌似会因为墙的原因使用在线安装包会失败，可以下载打包好的文件夹，在SourceForge中下载就好。 接下来分别介绍三种配置方法 一、官方配置教程配置三个.JSON文件，搭建基本环境使用VS code编写C/C++需要建立一个工作区域的文件夹，在这个文件夹里搭建好环境。我的做法是先搭建好一个文件夹作为模板，后续使用的时候复制该文件夹。 新建一个文件夹，在文件夹中新建一个helloworld.cpp（命名不要换别的，后续会有说明）文件，并通过VS code打开该文件夹。 配置c_cpp_properties.json文件使用快捷键ctrl+shift+p调出命令界面，输入Cpp以找到C/Cpp: Edit configurations命令 按照注释复制以下代码到文件中 1234567891011121314151617181920&#123; "configurations": [ &#123; "name": "Win32", "includePath": [ "$&#123;workspaceFolder&#125;/**" ], "defines": [ "_DEBUG", "UNICODE", "_UNICODE" ], "compilerPath": "C:\\MinGW\\mingw64\\bin\\gcc.exe",//这里替换成自己电脑上对应的地址 "cStandard": "c11", "cppStandard": "c++17", "intelliSenseMode": "msvc-x64" &#125; ], "version": 4&#125; 配置tasks.json文件使用快捷键ctrl+shift+p调出命令界面，找到Tasks: Configure Task命令 单击后点击使用模板创建task.json文件 单击Others 将下述代码复制到文件中 1234567891011121314151617&#123; "version": "2.0.0", "tasks": [ &#123; "label": "build hello world", "type": "shell", "command": "g++", "args": [ "-g", "helloworld.cpp" ], "group": &#123; "kind": "build", "isDefault": true &#125; &#125; ]&#125; 配置launch.json文件单击调试或者使用快捷键F5调出调试界面 选择C++（GDB/LLDB） 按注释中的提示粘贴以下代码到弹出来的文件中 1234567891011121314151617181920212223242526&#123; "version": "0.2.0", "configurations": [ &#123; "name": "(gdb) Launch", "type": "cppdbg", "request": "launch", "program": "$&#123;workspaceFolder&#125;/a.exe", "args": [], "stopAtEntry": false, "cwd": "$&#123;workspaceFolder&#125;", "environment": [], "externalConsole": true, "MIMode": "gdb", "miDebuggerPath": "C:\\MinGW\\mingw64\\bin\\gdb.exe",//替换成自己电脑上对应的位置 "setupCommands": [ &#123; "description": "Enable pretty-printing for gdb", "text": "-enable-pretty-printing", "ignoreFailures": true &#125; ], "preLaunchTask": "build hello world" &#125; ]&#125; 各种设置上述三个文件写好之后保存，基本的环境就已经搭建起来了,在.cpp中编写好代码，使用快捷键F5就可以看到一闪而过的终端，表明环境搭建正确，已经可以使用VS code进行C/C++的编程。 但以上三个文件都是按照官网给的示例配置的，使用起来可能不是很顺手，我是在它的基础上修改了一些 修改.cpp命名在官网给出的文档中，默认了使用helloworld.cpp这个文件名，若想替换的话，需要修改task.json文件的args参数，以main.cpp为例 123"args": [ "-g", "helloworld.cpp"], 修改为 123"args": [ "-g", "main.cpp"], 修改.exe文件名经GCC编译出的程序默认名为a.exe,和我的习惯不太搭，这个也是可以修改的，其实如果了解过GCC的话，很容易就能猜出task.json文件的args参数就是使用GCC编译时的命令，所以只需要在原有基础上再添加一个命令就好。 这里以main.exe为例，在task.json中添加下列命令 1234"args": [ ...... "-o", "main.exe"], 之后修改launch.json中的program参数为 1"program": "$&#123;workspaceFolder&#125;/main.exe", 终端一闪而逝有个比较难接受的事情是使用VS code进行调试时程序一旦结束终端就会关掉，给调试带来了一定的困难，这点的原因是程序结束了就结束了，一些IDE会在最后加上一个命令让它停在那里，而VS code自然不会带这个，比较一般的解决方案是在代码最后加上getchar(),cin.get(),system(&quot;pause&quot;)这样的代码，在绝大多数情况下这样写显示的结果和需要的是一样的 OI/ACM ICPC等算法题目的文件重定向在很多算法竞赛或者是算法题目中，后台会将提交的代码输入输出重定向到对应的文件中，这样处理起来会很快。而在写题的时候，也有不少选手也会做类似的处理，加上freopen之类函数，一方面测试的速度可以加快，另一方面也能很好的对数据进行分析。 而在VS code中，可以通过一些小配置达到更理想的情况，使程序从一个指定文件中读入数据并输出到另一个指定的文件中，原理也是使用了一些命令。 以从同目录下的in.txt读入并输出到out.txt为例。 在task.json文件的&quot;args&quot;: []中添加参数，效果如下 123456"args": [ "&lt;", "in.txt", "&gt;", "out.txt"], 这样就实现了从in.txt中读取数据并输出到out.txt中。 关于使用vscode做算法竞赛请看这篇&lt;&lt;以最优雅的方式做算法竞赛&gt;&gt; 二、使用C/C++ Compile Run插件老实讲这个方法我是拒绝的o((&gt;ω&lt; ))o，之前为了配置环境，写配置文件看了很多东西，结果用这种方法，竟然这么简单…… 下载C/C++ Compile Run直接在VS code的插件商店里搜索C/C++ Compile Run然后一路安装重新加载。配置完成！ 使用F6一键编译运行写好C/C++程序之后，直接使用F6一键编译运行就能出结果。QAQ 可以看出来程序在终端页面进行执行，成功运行并结束。 而且更关键的是，这个编译运行的是当前编辑的文件，也就是说，不必一个文件夹配置一个环境来编写程序，只要有代码就好,,ԾㅂԾ,, 和官网的方法比起来，使用C/C++ Compile Run插件更为方便快捷，也更加简单，但是因为没有了配置文件，灵活性会差点。 三、使用终端方法二中插件的做法给了我另外一种思路。 既然在Windows下本质都是间接使用mingw，那为什么不直接在命令行用mingw呢？比较令人兴奋的是，VS code提供了另一种使用终端的方法 使用ctrl+shift+`打开终端在VS code中，可以使用快捷键ctrl+shift+`新建一个终端(有点类似于在一些安装了图形化界面的Linux中在当前文件夹打开终端的命令)。 接着，使用g++ main.cpp -o main.exe或者gcc main.cpp -o main.exe编译源代码 使用./main.exe运行程序 能够在在VS code里使用终端还是挺让人惊艳的，而直接利用mingw进行编译，速度较其它方法快多了，而且可以通过调整参数，使得编译更加的灵活。 一些推荐的插件毕竟用VS code的还是因为想要个好看的界面，有一些有意思的插件不得不说下 background 为VS code加上一个可爱的小姑娘作为背景（。＾▽＾），亦可以自定义最多三张图片作为背景图片，配置的时候需要一些简单的CSS基础。 Bracket Pair Colorizer 彩虹花括号插件，为代码中的括号加上色彩，整体更加漂亮，结构也比较清晰。 One Dark Pro 一个主题插件，蛮好看的倒是。 一些小tip除了使用插件之外，VS code还有一大堆设置，具体都在文件=&gt;首选项=&gt;设置里，不过能看到有用户设置与工作区设置，他们之间的关系有点类似于C语言中的全局变量与局部变量，如果修改了工作区设置，会在当前文件夹中自动生成一个settings.json文件，记录下各个改动，对于某一工作区而言，工作区设置的优先级要高于用户设置，一旦工作区设置中的某项设置不为默认值，则使用工作区设置下的该项设置，否则采用用户设置下的该项设置 写在后面到目前为止，VS code依旧是我用起来最顺手的编辑器没有之一┗|｀O′|┛ 嗷~~，它优秀而又强大的扩展性满足了我对一个编辑器的绝大多数想象，我在不断的折腾中一次又一次的见识到了它的魅力，我相信它会伴随我相当一段时间。 后续的话，会逐渐写些VS code对其它语言的支持，当然前提是学了那些语言👻。不过目前的打算是先学精一门语言，漫无目的的游荡了好长时间，我得静下心来了。]]></content>
      <categories>
        <category>教程</category>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Proteus安装，破解，汉化教程]]></title>
    <url>%2F2018%2F11%2F07%2FProteus%E5%AE%89%E8%A3%85%EF%BC%8C%E7%A0%B4%E8%A7%A3%EF%BC%8C%E6%B1%89%E5%8C%96%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[最近在学校里做电路实验，老师要求在自己的电脑上下载Proteus这款软件并进行模拟仿真实验，于是在网上搜寻了相关的教程，整理后理清了整个安装破解的思路与方法。写下来，一是留作以后备用，不用再查很多资料，二是熟悉下Markdown的语法，当作一个练手的博客。 其实使用破解软件从根本上讲是不对的，如果有能力的话，一定要支持正版。即便是现在没有能力，等到以后有能力承担得起正版所需要支付的费用的时候，一定要补回自己使用曾使用盗版而躲过的费用。 声明：本教程是从互联网上搜集整理而成，资源资料都来自互联网，并非原创。 本教程选取的Proteus版本为Proteus 8.7 SP3 Professional，是写此教程时能找到的最新的版本 资源下载下载Proteus相关资源 下载好后，会有两个文件夹和一个.exe的可执行文件，其中，一个是汉化包文件夹，里面包含了汉化Proteus所需的汉化包；一个是破解文件文件夹，通过替换对应文件来实现破解；最后一个是Proteus8.7的安装程序，从官网下载的话需要科学上网，因为显而易见的原因这对绝大多数人来讲不是件可以做到的事情，因此使用在网上传播的整合好的安装程序。 安装双击安装程序进行安装 点击Next 将I accept the terms of this agreement.选中，之后点击Next 保持默认的选项点击Next 点击Next 在弹出的界面里，点击左下角的Browser For Key File （浏览文件夹找许可证） 许可文件是破解文件文件夹的Crack文件夹中的Licence.lxk，选中后点击右下角的打开 当界面如图显示时，点击左下角的Install，进行安装许可证 在弹出的界面中点击是 当界面如图所示的时候，点击右下角的Close 图上的选项是对早期版本的一些兼容，如果理解的话可以酌情选择，否则的话，直接点击Next 选择第一个进行安装，二者的差异右边解释的很详尽，如果不理解的话，直接选第一个就好 等待 安装过程结束，先不要运行，点击右下角Close关闭安装程序，准备开始破解。 破解Proteus是默认安装在C盘中的，这点我暂时还没有找到迁移的方法，如果有想法的话，欢迎来讨论。如果是在windows10系统中，打开C:\Program Files (x86)\Labcenter Electronics\Proteus 8 Professional这个目录，这是Proteus的关键文件目录Proteus的一些关键文件就在这个目录下：C=&gt; Program Files (x86) =&gt; Labcenter Electronics =&gt; Proteus 8 Professional 打开破解文件文件夹=&gt;Crack=&gt;Proteus 8 Professional 将破解文件文件夹中的BIN文件复制到Proteus的关键文件目录中 在弹出的窗口中选择替换目标中的文件 至此，Proteus 8.7破解完成，启动Proteus即可使用 汉化其实大致看看也能看懂各个单词的意思，汉化不是什么很必须的事情 打开Proteus的关键文件目录和汉化包文件夹 打开汉化包文件夹的中文语言包文件夹与Proteus关键文件目录的Translations文件夹 将中文语言包文件夹中的proteus_zh_CN.qm文件复制到Translations文件夹中，至此，Proteus 8.7汉化完成 简单使用打开主页面后，点击新建工程 选择新工程，修改完路径与工程名之后，点击下一步 点击下一步 点击下一步 点击下一步 点击完成 初始界面如图 如果想找到某个元件，可依此点击P，填写关键字，双击需要的元件将其添加到菜单中 或者点击L，在库中按照分类寻找 绘制出一个简单的电路 点击左下角三角形按钮开始运行]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>proteus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2018%2F11%2F01%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[今天是2018年11月1日，据我开始打算搭建一个私人博客起，刚刚好一个月，找了各种各样的博客，各种各样的教程，向认识的同学请教，在GitHub上提问，在文档之间徘徊。一个月，缝缝补补，终于是把基本的博客搭了起来，以后的话，就可以在这里，巨大的互联网的一角里存放属于自己的一点一滴。 写在之前博主本人呢，在写这篇博文的时候还是一个在校的大二大学生，有着这个年龄的朝气蓬勃与昂扬向上，对一切抱有很大的热情，也有着一颗经常迷茫的心，迷茫这个时期的自己到底要做些什么，选择什么样的道路。有时候会是拖延症晚期，扎在角落里不想动，有时候又会精力过剩，搭乘着各种各样的交通工具抵达各种各样的远方。博主最自豪的是有着一颗热爱技术的心，有着足够的激情，去从零开始学习一个又一个的技术。不甘放弃，无论是什么样的时候，都不会放弃自己最内心的坚持。 想要写博客写博客这个想法自大一就有了，当时初学C语言，刷了很多算法题，当有不会的时候，就经常在网上搜索题解，经常看见大神在博客里记下解题思路与代码，受益匪浅，当时就有一起学习的同学说也要写博客什么的，虽然也会有触动，但也就是一笑而过而已。 直到大一暑假在学校进行ACM/ICPC集训的时候，学长推荐的一个博客真真正正的惊艳了我，那是个私人搭建的博客，和CSDN，博客园那样固定的搭配不一样，淡雅，平淡，没有很多烦人的广告，有的，只是一篇讲解深刻的算法博客。那时，搭建一个私人博客的想法，才真真正正的在心里有了雏形。 而真正开始着手搭建博客，则是在大二的国庆佳节，彼时我已经参观过同级同学的博客，有的内容详实，有的令人惊艳，记忆深刻，再加上因为各种原因，没有出去玩，在学校宿舍窝着发霉，最后就在某一刻，打开Tim，找到了技术比较在线的大佬。 “在不？” “咋？” “我想搭个博客，求助。” “OK” 开始搭建博客说来虽然很受益于CSDN，博客园以及豆瓣这些比较大型的博客网站，但是个人不是很喜欢自己的博客里夹杂太多不属于自己的东西在里面，尤其是我特备厌恶的广告，恰巧当时知道可以在GitHub上搭建一个拥有二级域名的Github博客，再加上Github给人带来的专业感是其他网站所不能比拟的，于是最初的打算就是在GitHub上搭建博客，结果在网上教程和同学的引导下，最终决定通过Coding和GitHub双线部署到自己的独立域名的方式搭建博客，事实证明，这种拥有并不断维护一个个人的网站的感觉还是蛮不错的( ˘•ω•˘ )。 由于是个前端渣，没能力自己写出很酷炫的网页特效出来，因此听了同学和教程的建议，使用了Hexo来搭建博客，主题用了使用人数最多的NexT，简洁而不失美感。最开始的时候，修改各种配置文件到头秃，十一国庆期间，有好些天改一个配置到凌晨。最开始是按着NexT的文档改，结果发现他的文档里有好多配置没有详细说明╮(╯▽╰)╭，只好从配置文件里找到各个插件的网站再看各自的文档，总的来说，也是挺折腾的。不过，收获也很大，之前在别的博客里有见到过背景上的折线动画，第一次见的时候玩了半天（//▽//）,然后……一行配置解决了((٩(//̀Д/́/)۶))。 但印象更深刻的是一些博客左下角的看板娘，从看到过的博客来讲，需要折腾更久，暂时就没整。然后的话，本来也照着教程整了很久的评论系统，然后最后发现需要有后台的服务器，emmmm穷学生就先不考虑了，先把最基本的功能做出来就好。 写什么呢不过对于博客来讲的话，搭建环境反而是最简单的一部分吧，整个博客的关键在于一篇篇内容详实的博文，否则就是华而不实了，也就违背了搭建博客的初衷了，这点的话，作为一个（前）ACM/ICPC校队队员o(TヘTo)，偶尔还会继续做做算法题，写本篇博文的时候，还在肝紫书，那样的话，一方面可以考虑写写题解，记下比较有意思的算法，一些奇奇怪怪的题的思路；然后的话，记下折腾过的各种小东西吧，比如说搞一下VS code来编译C++程序的过程；还有的话，我的方向倒是游戏开发，目前在用的开发引擎是unity，可以的话，写下学习笔记，或者记下开发一个小工程的开发全过程；再记下一些技术博客和个人的想法吧，有好久没写过日记了，在博客里记录下生活也是可以考虑的；还有的话，想要转载一些大佬的博客，那些让我从杂乱无章的思绪中一下子脱离出来的博文，怎么想，都还是想要存起来。 我还一直有个想法，做一个比较漂亮的页面出来，类似是个技能熟练度的进度条，技能分别是计算机领域的各种语言啦，算法啦之类的，语言的话，像C/C++，C#，Java，Python，Html，CSS，Javascript，Markdown……专业工具：Unity，Photoshop，Prime，3DMAX，Matlab……系统：Windows，Linux等吧，熟练度的话，就是从精通拼写到精通吧(..•˘_˘•..)。 对了，在了解博客之后，我才知道是要用Markdown写博客的，那样的话，要稍稍学一下Markdown，然后需要一个顺手的编辑器，虽然听说Atom和Typora都是挺不错的Markdown编辑器，但无奈用不惯，反过来继续用了VS code了，最近听到Visual Studio和VS code支持JAVA了，还有了一些很有趣的功能，所以，对这个编辑器还是很抱有希望的。 写在最后洋洋洒洒写了有两千多字吧，只是随手写写能凑够这么多数也是挺吃惊的，想想在学校编个论文写到绝望，差距还是挺大的。那么。过去一个月来说，是很迷茫无助的一个月，这些日子所有的一个人的时间都留给了博客，终于搭建完后，心里怎么说呢，有种豁然开朗的感觉，无论如何，果然最不愿意说放弃的是自己啊。新的一个月，一个新的开始。 加油吧，少年！]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
</search>
